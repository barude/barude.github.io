<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Last Draft</title>
    <style>
        /* --- THEME --- */
        :root {
            --bg: #101010;
            --paper: #181818;
            --text: #e0e0e0;
            --accent: #4a90e2;
            --select-highlight: rgba(74, 144, 226, 0.25);
            --font: 'Courier Prime', 'Courier New', Courier, monospace;
        }

        /* Light Mode - Gentle on the eyes */
        body.light-mode {
            --bg: #f5f3ef;
            --paper: #faf8f4;
            --text: #3a3834;
            --select-highlight: rgba(74, 144, 226, 0.15);
        }

        body.light-mode #floating-actions button {
            background: rgba(250, 248, 244, 0.9);
            color: #4a4844;
            border: 1px solid rgba(200, 195, 185, 0.5);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        body.light-mode #floating-actions button:hover {
            background: rgba(245, 243, 239, 0.95);
            border-color: rgba(180, 175, 165, 0.7);
        }

        body.light-mode .container-box {
            border-left-color: rgba(100, 150, 255, 0.25);
        }

        body.light-mode .container-header {
            opacity: 0.5;
        }
        body.light-mode .container-box:hover .container-header {
            opacity: 1;
        }
        body.light-mode .container-version-controls {
            color: #7a7874;
        }
        body.light-mode .container-version-btn {
            color: #7a7874;
        }
        body.light-mode .container-version-btn:hover {
            background: rgba(100, 150, 255, 0.15);
            color: #6a6864;
        }
        body.light-mode .container-version-number {
            color: #7a7874;
        }
        body.light-mode .container-add-btn {
            color: #4a8;
        }
        body.light-mode .container-add-btn:hover {
            color: #5b9;
            background: rgba(90, 170, 153, 0.15);
        }
        body.light-mode .container-ungroup-btn {
            color: #955;
        }
        body.light-mode .container-ungroup-btn:hover {
            color: #a66;
            background: rgba(170, 102, 102, 0.15);
        }

        body.light-mode .gutter select.type-select {
            background: #f5f3ef;
            color: #5a5854;
            border-color: rgba(200, 195, 185, 0.6);
        }

        body.light-mode #selection-bar {
            background: #faf8f4;
            border-color: rgba(200, 195, 185, 0.6);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        body.light-mode #selection-bar span {
            color: #5a5854;
        }

        body.light-mode #selection-bar button {
            background: #f5f3ef;
            color: #4a4844;
            border-color: rgba(200, 195, 185, 0.5);
        }

        body.light-mode #selection-bar button.primary {
            background: #4a4844;
            color: #faf8f4;
        }

        /* RESET */
        html, body { height: 100%; margin: 0; padding: 0; }
        
        body {
            background: var(--bg); color: var(--text);
            display: flex; flex-direction: column; font-family: -apple-system, sans-serif;
            overflow: hidden; 
        }

        /* --- FLOATING ACTION BUTTONS --- */
        #floating-actions {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
        }
        
        #floating-actions button {
            width: 40px;
            height: 40px;
            background: rgba(34, 34, 34, 0.85);
            color: #ccc;
            border: 1px solid rgba(68, 68, 68, 0.6);
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            backdrop-filter: blur(8px);
            padding: 0;
        }
        
        #floating-actions button:hover {
            background: rgba(68, 68, 68, 0.9);
            color: white;
            border-color: rgba(100, 100, 100, 0.8);
            transform: scale(1.05);
        }
        
        #floating-actions button:active {
            transform: scale(0.95);
        }
        
        #floating-actions button[title] {
            position: relative;
        }

        /* --- WORKSPACE --- */
        #workspace {
            flex: 1; 
            overflow-y: scroll; 
            display: flex; 
            justify-content: center;
            padding: 0; 
            background: var(--bg);
            scroll-behavior: smooth;
        }
        
        #page {
            width: 850px; 
            height: max-content; 
            min-height: 100vh; 
            padding-bottom: 60vh; 
            background: var(--paper);
            box-shadow: 0 0 50px rgba(0,0,0,0.5); 
            padding-top: 80px; padding-left: 96px; padding-right: 96px; 
            display: flex; 
            flex-direction: column; 
            position: relative;
        }
        
        #page-buffer {
            display: none;
            width: 850px; 
            height: max-content; 
            min-height: 100vh; 
            padding-bottom: 60vh; 
            background: var(--paper);
            box-shadow: 0 0 50px rgba(0,0,0,0.5); 
            padding-top: 80px; padding-left: 96px; padding-right: 96px; 
            display: flex; 
            flex-direction: column; 
            position: relative;
        }
        
        #page.rendering {
            opacity: 0;
            pointer-events: none;
        }

        /* -------------------- CORE BLOCK MODEL -------------------- */

        .row {
            display: block;
            position: relative;
            border-left: 3px solid transparent;
            margin: 0;           /* we control vertical rhythm only via margin-top */
            padding: 0;
        }

        /* All bottom margins are 0. Spacing = margin-top of the NEXT block. */
        .row.multi-selected {
            background: var(--select-highlight);
            border-left-color: var(--accent);
        }

        /* Vertical rhythm is purely "before paragraph" like Pages:
           Scene - 25pt before (~33px)
           Action - 12pt before (~16px)
           Character - 12pt before (~16px)
           Dialogue - 0
           Parenthetical - 0
           Transition - 12pt before (~16px)
        */

        /* First element on page: give it a nice top offset */
        #page > .row:first-child {
            margin-top: 33px;
        }

        /* Scene headings */
        .row.scene {
            margin-top: 33px;        /* ~25pt before */
            margin-bottom: 0;
        }

        /* Action paragraphs */
        .row.action {
            margin-top: 16px;        /* ~12pt before */
            margin-bottom: 0;
        }

        /* Character: start of dialogue block */
        .row.character {
            margin-top: 16px;        /* ~12pt before */
            margin-bottom: 0;
        }

        /* Parenthetical & Dialogue: glued to whatever is above (0 before) */
        .row.parenthetical,
        .row.dialogue {
            margin-top: 0;
            margin-bottom: 0;
        }

        /* Transition */
        .row.transition {
            margin-top: 16px;        /* ~12pt before */
            margin-bottom: 0;
        }

        /* CRITICAL: 0pt BETWEEN character / parenthetical / dialogue
           Because we use ONLY margin-top, this is already satisfied:
           - character has margin-top: 16, but parenthetical/dialogue have margin-top: 0
           So:
             character
             parenthetical
             dialogue
           => parenthetical/dialogue sit flush under the previous row.
        */

        /* -------------------- GUTTER CONTROLS -------------------- */

        .gutter {
            position: absolute; 
            left: -250px; 
            top: 50%;
            transform: translateY(-50%);
            width: 230px;
            display: flex; 
            justify-content: flex-end; 
            align-items: center; 
            gap: 0;
            opacity: 0; 
            padding-top: 0; 
            transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 10;
        }
        
        /* When a dropdown is open, ensure it's above everything */
        .row:has(.type-select-menu.open) {
            z-index: 10000;
            position: relative;
        }
        
        .row:has(.type-select-menu.open) .gutter {
            z-index: 10001;
        }
        
        /* Ensure dropdown menu and wrapper create proper stacking context */
        .type-select-wrapper:has(.type-select-menu.open) {
            z-index: 10002;
            position: relative;
        }
        .row:hover .gutter, .row:focus-within .gutter { opacity: 1; }
        .row.multi-selected .gutter { display: none !important; }

        /* Unified container for all gutter controls */
        .gutter-container {
            display: flex;
            align-items: center;
            gap: 0;
            background: #141414;
            border: 1px solid rgba(220, 220, 220, 0.15);
            border-radius: 4px;
            padding: 0;
            position: relative;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .row:hover .gutter-container,
        .row:focus-within .gutter-container {
            background: #151515;
            border-color: rgba(220, 220, 220, 0.2);
        }

        select.type-select {
            background: rgba(30, 30, 30, 0.4);
            color: #aaa;
            border: 1px solid rgba(60, 60, 60, 0.6);
            border-bottom: 1px solid rgba(80, 80, 80, 0.8);
            font-size: 10px;
            font-weight: 500;
            letter-spacing: 2px;
            padding: 5px 8px 4px 8px;
            width: 72px;
            outline: none;
            height: auto;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: var(--font);
            text-transform: uppercase;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            position: relative;
            backdrop-filter: blur(2px);
            box-shadow: none;
        }
        
        select.type-select:hover {
            color: #ddd;
            border-color: rgba(100, 100, 100, 0.8);
            border-bottom-color: rgba(120, 120, 120, 1);
            background: rgba(35, 35, 35, 0.5);
            letter-spacing: 2.5px;
        }
        
        select.type-select:focus {
            color: var(--accent);
            border-color: rgba(74, 144, 226, 0.4);
            border-bottom-color: var(--accent);
            background: rgba(40, 40, 40, 0.6);
            letter-spacing: 2.5px;
        }

        /* Custom dropdown arrow - more refined */
        select.type-select {
            background-image: url("data:image/svg+xml,%3Csvg width='7' height='4' viewBox='0 0 7 4' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L3.5 3L6 1' stroke='%23aaa' stroke-width='1.2' stroke-linecap='square' stroke-linejoin='miter'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 6px center;
            padding-right: 18px;
        }

        select.type-select:hover {
            background-image: url("data:image/svg+xml,%3Csvg width='7' height='4' viewBox='0 0 7 4' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L3.5 3L6 1' stroke='%23ddd' stroke-width='1.2' stroke-linecap='square' stroke-linejoin='miter'/%3E%3C/svg%3E");
        }

        select.type-select:focus {
            background-image: url("data:image/svg+xml,%3Csvg width='7' height='4' viewBox='0 0 7 4' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L3.5 3L6 1' stroke='%234a90e2' stroke-width='1.2' stroke-linecap='square' stroke-linejoin='miter'/%3E%3C/svg%3E");
        }

        /* Dropdown menu styling - cohesive with gutter design */
        select.type-select option {
            background: rgba(30, 30, 30, 0.98);
            color: #aaa;
            padding: 7px 10px;
            font-size: 10px;
            font-weight: 500;
            letter-spacing: 2px;
            font-family: var(--font);
            text-transform: uppercase;
            border: none;
            margin: 0;
            outline: none;
            backdrop-filter: blur(4px);
            min-height: 26px;
            line-height: 1.5;
            display: block;
        }

        select.type-select option:hover {
            background: rgba(40, 40, 40, 0.98);
            color: #ddd;
        }

        select.type-select option:checked,
        select.type-select option:focus {
            background: rgba(50, 50, 50, 0.98);
            color: var(--accent);
            font-weight: 500;
        }

        /* Ensure dropdown menu has consistent border treatment */
        select.type-select:focus {
            border-radius: 0;
            box-shadow: 0 0 0 1px rgba(60, 60, 60, 0.6);
        }

        /* Custom dropdown container */
        .type-select-wrapper {
            position: relative;
            display: inline-block;
            z-index: 10000;
        }
        
        .type-select-wrapper:has(.type-select-menu.open) {
            z-index: 10001;
        }

        .type-select-button {
            background: transparent;
            color: #e0e0e0;
            border: none;
            font-size: 10px;
            font-weight: 400;
            letter-spacing: 0.5px;
            padding: 6px 10px;
            width: auto;
            min-width: 60px;
            outline: none;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: var(--font);
            text-transform: uppercase;
            position: relative;
            box-shadow: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .type-select-button:hover {
            color: #f0f0f0;
        }

        .type-select-button.open {
            color: #e0e0e0;
        }

        .type-select-arrow {
            width: 7px;
            height: 4px;
            margin-left: 3px;
            transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            flex-shrink: 0;
        }

        .type-select-button.open .type-select-arrow {
            transform: rotate(180deg);
        }

        .type-select-menu {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 1px;
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid rgba(60, 60, 60, 0.6);
            backdrop-filter: blur(4px);
            z-index: 10002;
            min-width: 60px;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
            isolation: isolate;
        }

        .type-select-menu.open {
            display: block;
        }

        .type-select-option {
            background: transparent;
            color: #aaa;
            padding: 7px 10px;
            font-size: 10px;
            font-weight: 500;
            letter-spacing: 2px;
            font-family: var(--font);
            text-transform: uppercase;
            border: none;
            width: 100%;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            display: block;
            outline: none;
            position: relative;
            z-index: 10003;
            pointer-events: auto;
        }

        .type-select-option:hover {
            background: rgba(40, 40, 40, 0.95);
            color: #ddd;
        }

        .type-select-option.active {
            background: rgba(50, 50, 50, 0.95);
            color: var(--accent);
            font-weight: 500;
        }

        /* Divider between type and version controls */
        .gutter-container::after {
            content: '';
            width: 1px;
            height: 18px;
            background: rgba(74, 144, 226, 0.15);
            margin: 0;
        }

        .version-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            background: transparent;
            border: none;
            padding: 6px 10px 6px 10px;
            position: relative;
        }


        .version-controls button {
            background: transparent;
            border: none;
            color: #bbb;
            font-size: 11px;
            width: 16px;
            height: 16px;
            padding: 0;
            margin: 0;
            cursor: pointer;
            border-radius: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            line-height: 1;
            font-family: var(--font);
            position: relative;
        }

        .version-controls button:hover {
            color: #ccc;
        }

        .version-controls button:active {
            color: #aaa;
        }

        .version-number {
            font-size: 11px;
            color: #e0e0e0;
            padding: 0;
            min-width: 8px;
            text-align: center;
            font-weight: 400;
            user-select: none;
            font-family: var(--font);
            letter-spacing: 0;
            position: relative;
        }

        .version-controls .add-version-btn {
            color: #bbb;
            font-weight: 400;
            margin-left: 0;
            font-size: 11px;
            width: 16px;
            height: 16px;
        }

        .version-controls .add-version-btn:hover {
            color: #ccc;
        }

        /* Light mode styles for gutter */
        body.light-mode .gutter::after {
            background: rgba(200, 195, 185, 0.4);
        }

        body.light-mode select.type-select {
            background: rgba(250, 248, 244, 0.6);
            color: #5a5854;
            border: 1px solid rgba(200, 195, 185, 0.6);
            border-bottom: 1px solid rgba(180, 175, 165, 0.8);
            background-image: url("data:image/svg+xml,%3Csvg width='7' height='4' viewBox='0 0 7 4' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L3.5 3L6 1' stroke='%235a5854' stroke-width='1.2' stroke-linecap='square' stroke-linejoin='miter'/%3E%3C/svg%3E");
        }

        body.light-mode select.type-select:hover {
            color: #4a4844;
            border-color: rgba(180, 175, 165, 0.8);
            border-bottom-color: rgba(160, 155, 145, 0.9);
            background: rgba(250, 248, 244, 0.8);
            background-image: url("data:image/svg+xml,%3Csvg width='7' height='4' viewBox='0 0 7 4' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L3.5 3L6 1' stroke='%234a4844' stroke-width='1.2' stroke-linecap='square' stroke-linejoin='miter'/%3E%3C/svg%3E");
        }

        body.light-mode select.type-select:focus {
            color: var(--accent);
            border-color: rgba(74, 144, 226, 0.4);
            border-bottom-color: var(--accent);
            background: rgba(250, 248, 244, 0.9);
            background-image: url("data:image/svg+xml,%3Csvg width='7' height='4' viewBox='0 0 7 4' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L3.5 3L6 1' stroke='%234a90e2' stroke-width='1.2' stroke-linecap='square' stroke-linejoin='miter'/%3E%3C/svg%3E");
        }

        body.light-mode select.type-select option {
            background: rgba(250, 248, 244, 0.98);
            color: #5a5854;
        }

        body.light-mode select.type-select option:hover {
            background: rgba(245, 243, 239, 0.98);
            color: #4a4844;
        }

        body.light-mode select.type-select option:checked,
        body.light-mode select.type-select option:focus {
            background: rgba(240, 238, 234, 0.98);
            color: var(--accent);
            font-weight: 500;
        }

        body.light-mode .gutter-container {
            background: #f5f3ef;
            border: 1px solid rgba(200, 195, 185, 0.3);
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.03);
        }

        body.light-mode .row:hover .gutter-container,
        body.light-mode .row:focus-within .gutter-container {
            background: #f8f6f2;
            border-color: rgba(200, 195, 185, 0.4);
        }

        body.light-mode .type-select-button {
            color: #4a4844;
        }

        body.light-mode .type-select-button:hover {
            color: #3a3834;
        }

        body.light-mode .gutter-container::after {
            background: rgba(74, 144, 226, 0.2);
        }

        body.light-mode .version-controls button {
            color: #7a7874;
        }

        body.light-mode .version-controls button:hover {
            color: #5a5854;
        }

        body.light-mode .version-number {
            color: #4a4844;
        }

        body.light-mode .version-controls .add-version-btn {
            color: #7a7874;
        }

        body.light-mode .version-controls .add-version-btn:hover {
            color: #5a5854;
        }

        body.light-mode .version-controls::before {
            background: var(--accent);
        }

        body.light-mode .version-controls button {
            color: #6a6864;
        }

        body.light-mode .version-controls button:hover {
            color: var(--accent);
        }

        body.light-mode .version-number {
            color: #5a5854;
        }

        body.light-mode .version-controls .add-version-btn {
            color: #6a6864;
        }

        body.light-mode .type-select-button {
            background: rgba(250, 248, 244, 0.6);
            color: #5a5854;
            border: 1px solid rgba(200, 195, 185, 0.6);
            border-bottom: 1px solid rgba(180, 175, 165, 0.8);
        }

        body.light-mode .type-select-button:hover {
            color: #4a4844;
            border-color: rgba(180, 175, 165, 0.8);
            border-bottom-color: rgba(160, 155, 145, 0.9);
            background: rgba(250, 248, 244, 0.8);
        }

        body.light-mode .type-select-button.open {
            color: var(--accent);
            border-color: rgba(74, 144, 226, 0.4);
            border-bottom-color: var(--accent);
            background: rgba(250, 248, 244, 0.9);
        }

        body.light-mode .type-select-menu {
            background: rgba(250, 248, 244, 0.95);
            border: 1px solid rgba(200, 195, 185, 0.6);
        }

        body.light-mode .type-select-option {
            color: #5a5854;
        }

        body.light-mode .type-select-option:hover {
            background: rgba(245, 243, 239, 0.95);
            color: #4a4844;
        }

        body.light-mode .type-select-option.active {
            background: rgba(240, 238, 234, 0.95);
            color: var(--accent);
        }
        
        /* -------------------- INPUT GRID -------------------- */

        .input-grid { 
            display: grid; 
            align-items: start;  /* Prevent extra vertical space */
        }
        
        .replicator, textarea {
            grid-area: 1 / 1 / 2 / 2;
            font-family: var(--font); font-size: 12pt; 
            line-height: 1.05;
            padding: 0; margin: 0; border: none; width: 100%;
            box-sizing: border-box; white-space: pre-wrap; word-wrap: break-word;
            display: block;
            height: auto;  /* Let height match content exactly */
            min-height: 0;  /* Remove default min-height */
        }
        
        /* Character, Parenthetical, Dialogue: tight line-height for 0pt spacing */
        .row.character .replicator,
        .row.character textarea,
        .row.parenthetical .replicator,
        .row.parenthetical textarea,
        .row.dialogue .replicator,
        .row.dialogue textarea {
            line-height: 1.0;
        }
        
        .replicator { 
            visibility: hidden; 
            pointer-events: none; 
            color: transparent; 
            min-height: 0;  /* Changed from 1em to 0 */
        }
        
        /* Show formatted text when textarea is not focused */
        .input-grid:not(:focus-within) .replicator {
            visibility: visible;
            color: var(--text);
            pointer-events: none;
        }
        
        .input-grid:focus-within textarea {
            color: var(--text);
        }
        
        .input-grid:not(:focus-within) textarea {
            color: transparent;
        }
        
        .replicator strong {
            font-weight: bold;
        }
        
        .replicator em {
            font-style: italic;
        }
        
        textarea { 
            background: transparent; 
            color: var(--text); 
            resize: none; 
            overflow: hidden; 
            outline: none;
            min-height: 0;  /* Remove default min-height */
            vertical-align: top;  /* Align to top to prevent extra space */
        }

        /* -------------------- CONTAINER (GROUP) -------------------- */

        .container-box {
            border-left: 2px solid rgba(100, 150, 255, 0.2);
            background: transparent;
            margin: 12px 0;
            padding: 0 0 0 8px; 
            position: relative;
        }
        .container-header {
            display: flex; 
            justify-content: flex-end; 
            align-items: center;
            margin-bottom: 8px; 
            padding: 4px 0;
            opacity: 0.4;
            transition: opacity 0.2s ease;
        }
        .container-box:hover .container-header {
            opacity: 1;
        }
        .container-label { 
            display: none;
        }
        .container-version-controls {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: #888;
        }
        .container-version-btn {
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            transition: all 0.15s ease;
            opacity: 0.7;
        }
        .container-version-btn:hover {
            background: rgba(100, 150, 255, 0.1);
            color: #aaa;
            opacity: 1;
        }
        .container-version-btn:active {
            background: rgba(100, 150, 255, 0.15);
        }
        .container-version-number {
            font-size: 10px;
            color: #666;
            padding: 0 4px;
            font-variant-numeric: tabular-nums;
        }
        .container-version-nav {
            font-size: 13px;
            line-height: 1;
            padding: 2px 4px;
        }
        .container-add-btn {
            color: #5a9;
            font-size: 10px;
            padding: 2px 8px;
        }
        .container-add-btn:hover {
            color: #6bb;
            background: rgba(90, 170, 153, 0.1);
        }
        .container-ungroup-btn {
            color: #a66;
            font-size: 10px;
            padding: 2px 8px;
            margin-left: 4px;
        }
        .container-ungroup-btn:hover {
            color: #b77;
            background: rgba(170, 102, 102, 0.1);
        }

        /* -------------------- FLOATING ACTION BAR -------------------- */

        #selection-bar {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: #222; border: 1px solid #444; border-radius: 8px;
            padding: 10px 20px; display: none; gap: 12px; align-items: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); z-index: 1000;
        }
        #selection-bar.visible { display: flex; animation: popUp 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes popUp { from { transform: translate(-50%, 20px); opacity: 0; } to { transform: translate(-50%, 0); opacity: 1; } }

        /* -------------------- FORMATTING -------------------- */

        .scene textarea, .scene .replicator { font-weight: bold; text-transform: uppercase; }
        .character textarea, .character .replicator { text-align: center; margin-left: 18%; width: 64%; text-transform: uppercase; }
        .parenthetical textarea, .parenthetical .replicator { margin-left: 28%; width: 44%; }
        .dialogue textarea, .dialogue .replicator { margin-left: 18%; width: 64%; }
        .transition textarea, .transition .replicator { text-align: right; text-transform: uppercase; }

        /* ARABIC (RTL) */
        .row[dir="rtl"] textarea, .row[dir="rtl"] .replicator { 
            direction: rtl; 
            unicode-bidi: embed;
        }
        .row[dir="rtl"].scene textarea, .row[dir="rtl"].scene .replicator { text-align: right; }
        .row[dir="rtl"].action textarea, .row[dir="rtl"].action .replicator { text-align: right; }
        .row[dir="rtl"].character textarea, .row[dir="rtl"].character .replicator { 
            text-align: center; 
            margin-right: 18%; 
            margin-left: 18%; 
        }
        .row[dir="rtl"].dialogue textarea, .row[dir="rtl"].dialogue .replicator { 
            text-align: right; 
            margin-right: 18%; 
            margin-left: 18%; 
        }
        .row[dir="rtl"].parenthetical textarea, .row[dir="rtl"].parenthetical .replicator { 
            text-align: right; 
            margin-right: 28%; 
            margin-left: 0; 
        }

        /* -------------------- TITLE PAGE MODAL -------------------- */
        #title-page-modal {
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 300;
            display: none;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #title-page-modal.open {
            display: flex;
            opacity: 1;
        }

        #title-page-content {
            background: var(--bg);
            border: 1px solid rgba(68, 68, 68, 0.6);
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        #title-page-content h2 {
            margin: 0 0 20px 0;
            color: var(--text);
            font-size: 20px;
            font-weight: bold;
            text-align: center;
        }

        .title-page-field {
            margin-bottom: 20px;
        }

        .title-page-field label {
            display: block;
            margin-bottom: 8px;
            color: var(--text);
            font-size: 13px;
            font-weight: 500;
        }

        .title-page-field input,
        .title-page-field textarea {
            width: 100%;
            padding: 10px;
            background: rgba(40, 40, 40, 0.8);
            border: 1px solid rgba(68, 68, 68, 0.6);
            border-radius: 4px;
            color: var(--text);
            font-size: 14px;
            font-family: -apple-system, sans-serif;
            box-sizing: border-box;
        }

        .title-page-field input:focus,
        .title-page-field textarea:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(50, 50, 50, 0.9);
        }

        .title-page-field textarea {
            resize: vertical;
            min-height: 60px;
        }

        #title-page-custom-areas {
            margin-top: 20px;
        }

        .title-page-custom-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .title-page-custom-header label {
            color: var(--text);
            font-size: 13px;
            font-weight: 500;
            margin: 0;
        }

        .add-custom-area {
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 4px;
            width: 28px;
            height: 28px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            transition: opacity 0.2s ease;
        }

        .add-custom-area:hover {
            opacity: 0.8;
        }

        .title-page-custom-item {
            margin-bottom: 15px;
            display: flex;
            gap: 8px;
            align-items: flex-start;
        }

        .title-page-custom-item textarea {
            flex: 1;
            resize: vertical;
            min-height: 60px;
        }

        .title-page-custom-item .remove-custom-area {
            background: rgba(255, 68, 68, 0.8);
            color: white;
            border: none;
            border-radius: 4px;
            width: 28px;
            height: 28px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            flex-shrink: 0;
            transition: opacity 0.2s ease;
        }

        .title-page-custom-item .remove-custom-area:hover {
            opacity: 0.8;
        }

        .title-page-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 30px;
        }

        .title-page-actions button {
            padding: 10px 20px;
            border: 1px solid rgba(68, 68, 68, 0.6);
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .title-page-actions button.primary {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .title-page-actions button.primary:hover {
            background: var(--accent);
            opacity: 0.9;
        }

        .title-page-actions button.secondary {
            background: rgba(40, 40, 40, 0.8);
            color: var(--text);
        }

        .title-page-actions button.secondary:hover {
            background: rgba(50, 50, 50, 0.9);
        }

        body.light-mode #title-page-modal {
            background: rgba(0, 0, 0, 0.5);
        }

        body.light-mode #title-page-content {
            background: rgba(250, 248, 244, 0.98);
            border-color: rgba(200, 195, 185, 0.5);
        }

        body.light-mode .title-page-field input,
        body.light-mode .title-page-field textarea {
            background: rgba(255, 255, 255, 0.9);
            border-color: rgba(200, 195, 185, 0.5);
            color: #4a4844;
        }

        /* Title page - hidden in screen view */
        #title-page-print {
            display: none;
        }

        /* Title page print styles */
        @media print {
            /* Special page rules for title page - use same margins as regular pages for consistency */
            @page:first {
                margin-top: 2.4cm !important;
                margin-right: 1.27cm !important;
                margin-bottom: 2.4cm !important;
                margin-left: 1.27cm !important;
                size: A4 !important;
            }

            #title-page-print {
                display: block !important;
                page-break-after: always !important;
                page-break-inside: avoid !important;
                break-after: page !important;
                break-inside: avoid !important;
                width: 100% !important;
                height: auto !important;
                min-height: 0 !important;
                max-height: 100% !important;
                padding: 0 !important;
                margin: 0 !important;
                margin-bottom: 0 !important;
                box-sizing: border-box !important;
                position: relative !important;
                overflow: hidden !important;
            }

            #title-page-print .title-page-content-wrapper {
                width: 6.5in !important;
                max-width: 6.5in !important;
                margin: 0 auto !important;
                padding: 3.5in 0 1in 0 !important;
                min-height: 0 !important;
                height: auto !important;
                max-height: none !important;
                display: flex !important;
                flex-direction: column !important;
                justify-content: flex-start !important;
                align-items: center !important;
                box-sizing: border-box !important;
                position: relative !important;
                font-family: var(--font) !important;
                color: black !important;
                overflow: hidden !important;
                page-break-inside: avoid !important;
                break-inside: avoid !important;
            }

            #title-page-print .title-page-title {
                text-align: center;
                font-size: 12pt;
                font-weight: normal;
                margin: 0 0 0.4in 0;
                line-height: 1.05;
                width: 100%;
                padding: 0;
                font-family: var(--font);
                color: black !important;
            }

            #title-page-print .title-page-written-by {
                text-align: center;
                font-size: 12pt;
                margin: 0 0 0.2in 0;
                line-height: 1.05;
                width: 100%;
                padding: 0;
                font-family: var(--font);
                color: black !important;
            }

            #title-page-print .title-page-writer {
                text-align: center;
                font-size: 12pt;
                font-weight: normal;
                margin: 0 0 0.4in 0;
                line-height: 1.05;
                width: 100%;
                padding: 0;
                font-family: var(--font);
                color: black !important;
            }

            #title-page-print .title-page-custom {
                text-align: center;
                font-size: 12pt;
                margin: 0.2in 0;
                line-height: 1.05;
                width: 100%;
                white-space: pre-line;
                padding: 0;
                font-family: var(--font);
                color: black !important;
            }

            #title-page-print .title-page-custom:first-of-type {
                margin-top: 0;
            }

            #title-page-print .title-page-custom:last-child {
                margin-bottom: 0;
            }

            /* Ensure script starts immediately after title page with no blank pages */
            /* Note: page-break-before removed since title page already forces break-after */
            #title-page-print + #page {
                margin-top: 0 !important;
                padding-top: 0 !important;
                page-break-before: auto !important;
            }
            /* Hide title page if it's empty to prevent blank page */
            #title-page-print:empty {
                display: none !important;
            }
            /* Remove top margin from first scene when it comes after title page */
            #title-page-print + #page > .row:first-child,
            #title-page-print + #page > .container-box:first-child > .row:first-child {
                margin-top: 0 !important;
                padding-top: 0 !important;
            }
            /* Also ensure the first scene itself has no top margin when after title page */
            #title-page-print + #page > .row.scene:first-child {
                margin-top: 0 !important;
            }
        }

        /* -------------------- SCENE MAP -------------------- */
        #scene-map {
            position: fixed;
            left: 0;
            top: 0;
            width: 240px;
            height: 100vh;
            background: rgba(20, 20, 20, 0.95);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(68, 68, 68, 0.6);
            z-index: 200;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #scene-map.open {
            transform: translateX(0);
        }

        .scene-map-header {
            padding: 20px 16px 12px 16px;
            font-size: 14px;
            font-weight: bold;
            color: var(--text);
            border-bottom: 1px solid rgba(68, 68, 68, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #scene-search {
            margin: 12px 16px;
            padding: 8px 12px;
            background: rgba(40, 40, 40, 0.8);
            border: 1px solid rgba(68, 68, 68, 0.6);
            border-radius: 4px;
            color: var(--text);
            font-size: 12px;
            outline: none;
            font-family: -apple-system, sans-serif;
        }

        #scene-search:focus {
            border-color: var(--accent);
            background: rgba(50, 50, 50, 0.9);
        }

        #scene-search::placeholder {
            color: #888;
        }

        #scene-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px 0;
        }

        .scene-item {
            padding: 10px 16px;
            color: var(--text);
            font-size: 12px;
            cursor: pointer;
            transition: background 0.15s ease;
            border-left: 3px solid transparent;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .scene-item:hover {
            background: rgba(68, 68, 68, 0.4);
            border-left-color: var(--accent);
        }

        .scene-item.active {
            background: rgba(74, 144, 226, 0.15);
            border-left-color: var(--accent);
        }

        .scene-drag-handle {
            cursor: grab;
            color: #888;
            font-size: 18px;
            user-select: none;
            padding: 4px 8px;
            flex-shrink: 0;
            pointer-events: auto;
            display: inline-block;
            line-height: 1;
            touch-action: none;
            margin-right: 4px;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-user-select: none;
        }

        .scene-drag-handle:active {
            cursor: grabbing;
            color: var(--accent);
        }

        .scene-drag-handle:hover {
            color: var(--accent);
            transform: scale(1.1);
        }


        .scene-item-content {
            flex: 1;
        }

        .scene-item.dragging {
            opacity: 0.5;
        }

        #page.drag-over {
            outline: 2px dashed var(--accent);
            outline-offset: -2px;
        }

        .row.drag-target {
            border-top: 2px solid var(--accent);
        }

        /* Drop indicator line */
        .drop-indicator {
            position: fixed;
            height: 4px;
            background: var(--accent);
            z-index: 10000;
            pointer-events: none;
            box-shadow: 0 0 12px var(--accent), 0 0 6px rgba(74, 144, 226, 0.5);
            opacity: 0;
            transition: opacity 0.15s ease;
            border-radius: 2px;
            display: block;
        }

        .drop-indicator.visible {
            opacity: 1;
        }

        /* Light mode styles for scene map */
        body.light-mode #scene-map {
            background: rgba(250, 248, 244, 0.95);
            border-right-color: rgba(200, 195, 185, 0.5);
        }

        body.light-mode .scene-map-header {
            border-bottom-color: rgba(200, 195, 185, 0.5);
        }

        body.light-mode #scene-search {
            background: rgba(245, 243, 239, 0.9);
            border-color: rgba(200, 195, 185, 0.5);
        }

        body.light-mode #scene-search:focus {
            background: rgba(250, 248, 244, 0.95);
            border-color: var(--accent);
        }

        body.light-mode .scene-item:hover {
            background: rgba(245, 243, 239, 0.6);
        }

        body.light-mode .scene-item.active {
            background: rgba(74, 144, 226, 0.1);
        }

        /* Jump highlight animation */
        .row.jump-highlight {
            animation: jumpFlash 1s ease;
        }

        @keyframes jumpFlash {
            0% { background: rgba(74, 144, 226, 0.4); border-left-color: var(--accent); }
            50% { background: rgba(74, 144, 226, 0.2); }
            100% { background: transparent; border-left-color: transparent; }
        }

        /* Search highlight */
        .search-highlight {
            background: rgba(255, 255, 0, 0.4);
            padding: 2px 0;
            border-radius: 2px;
            font-weight: bold;
        }

        body.light-mode .search-highlight {
            background: rgba(255, 255, 0, 0.6);
        }

        .scene-item.match {
            background: rgba(74, 144, 226, 0.2);
            border-left-color: var(--accent);
        }

        /* Highlight rows containing search matches */
        .row.search-match {
            background: rgba(255, 255, 0, 0.15);
            border-left: 3px solid rgba(255, 255, 0, 0.6);
        }

        body.light-mode .row.search-match {
            background: rgba(255, 255, 0, 0.25);
            border-left-color: rgba(255, 200, 0, 0.8);
        }

        /* -------------------- PRINT / PDF -------------------- */
        @media print {
            /* Force paper size and margins with !important for WebKit/Electron/Safari */
            @page {
                size: A4 !important;
                margin-top: 2.4cm !important;
                margin-right: 1.27cm !important;
                margin-bottom: 2.4cm !important;
                margin-left: 1.27cm !important;
            }
            
            /* Remove automatic browser padding - zero margin and padding for print */
            html {
                margin: 0 !important;
                padding: 0 !important;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            /* Hide all UI and editor chrome for print */
            #floating-actions, .gutter, .container-header, #selection-bar, #scene-map, #page-buffer { display: none !important; }
            /* Make container-box completely invisible to layout */
            .container-box { 
                display: block !important;
                border: 0 !important;
                border-width: 0 !important;
                padding: 0 !important;
                margin: 0 !important;
                margin-top: 0 !important;
                margin-bottom: 0 !important;
                margin-left: 0 !important;
                margin-right: 0 !important;
                background: transparent !important;
                height: auto !important;
                min-height: 0 !important;
                max-height: none !important;
                line-height: 0 !important;
                font-size: 0 !important;
                vertical-align: baseline !important;
                box-sizing: border-box !important;
                position: static !important;
            }
            .container-header { 
                display: none !important;
                margin: 0 !important;
                padding: 0 !important;
                height: 0 !important;
                min-height: 0 !important;
                max-height: 0 !important;
                line-height: 0 !important;
                font-size: 0 !important;
                overflow: hidden !important;
                visibility: hidden !important;
                position: absolute !important;
                left: -9999px !important;
                top: -9999px !important;
                width: 0 !important;
            }
            /* Remove any spacing from empty group message or other non-row elements */
            .container-box > div:not(.row) {
                display: none !important;
                margin: 0 !important;
                padding: 0 !important;
                height: 0 !important;
                min-height: 0 !important;
                max-height: 0 !important;
            }
            /* Ensure rows inside containers have normal spacing - exactly like rows outside */
            .container-box > .row {
                font-size: 13pt !important;
                line-height: normal !important;
                margin-left: 0 !important;
                margin-right: 0 !important;
                /* Rows keep their natural margin-top values - they should behave exactly like rows outside containers */
            }
            /* If container is first child of page, first row inside should get first-child spacing */
            #page > .container-box:first-child > .row:first-child {
                margin-top: 25pt !important;  /* Same as first row spacing, using pt for consistency */
            }
            body, #workspace { 
                background: white !important; 
                height: auto !important; 
                overflow: visible !important; 
                display: block !important;
                margin: 0 !important;
                padding: 0 !important;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            #page { 
                width: 210mm !important;
                max-width: 210mm !important;
                box-shadow: none !important; 
                padding: 2.4cm 1.27cm 2.4cm 1.27cm !important;
                margin: 0 !important; 
                height: auto !important;
                background: white !important; 
                color: black !important;
                display: block !important;
                box-sizing: border-box !important;
                position: relative !important;
                font-family: Courier, "Courier New", monospace !important;
                font-size: 13pt !important;
                line-height: 1.1 !important;
            }
            /* Content area is automatically constrained by @page margins */
            /* A4: 210mm - 1.27cm (left) - 1.27cm (right) = 187.46mm */
            #page > * {
                max-width: 100% !important;
                box-sizing: border-box !important;
            }
            /* In print, use replicator div instead of textarea for better rendering */
            textarea { 
                display: none !important;
            }
            /* Ensure input-grid has proper width constraints */
            .input-grid {
                width: 100% !important;
                max-width: 100% !important;
                box-sizing: border-box !important;
                overflow: visible !important;
            }
            .replicator {
                display: block !important;
                visibility: visible !important;
                color: black !important;
                white-space: pre-wrap !important;
                word-wrap: break-word !important;
                overflow-wrap: break-word !important;
                overflow: visible !important;
                height: auto !important;
                min-height: 0 !important;
                margin: 0 !important;
                padding: 0 !important;
                line-height: 1.1 !important;
                width: 100% !important;
                max-width: 100% !important;
                box-sizing: border-box !important;
                font-family: Courier, "Courier New", monospace !important;
                font-size: 13pt !important;
            }
            .replicator strong {
                font-weight: bold !important;
            }
            .replicator em {
                font-style: italic !important;
            }
            /* Fix RTL Arabic text rendering with proper Unicode bidi */
            .row[dir="rtl"] {
                direction: rtl !important;
                unicode-bidi: embed !important;
            }
            .row[dir="rtl"] .replicator {
                direction: rtl !important;
                unicode-bidi: embed !important;
                text-align: inherit !important;
                font-feature-settings: normal !important;
                text-rendering: optimizeLegibility !important;
                word-break: keep-all !important;
                overflow-wrap: normal !important;
                white-space: pre-wrap !important;
            }
            /* Ensure Arabic text nodes are properly handled */
            .row[dir="rtl"] .replicator * {
                direction: rtl !important;
                unicode-bidi: embed !important;
            }
            /* Prevent Arabic text from breaking incorrectly */
            .row[dir="rtl"] .replicator {
                font-variant-ligatures: normal !important;
                font-kerning: normal !important;
            }
            /* Ensure RTL text containers have proper constraints - browser handles content area via @page */
            .row[dir="rtl"].scene .replicator {
                text-align: right !important;
                width: 100% !important;
            }
            .row[dir="rtl"].action .replicator {
                text-align: right !important;
                width: 100% !important;
            }
            .row[dir="rtl"].character .replicator {
                text-align: center !important;
                margin-right: 18% !important;
                margin-left: 18% !important;
                width: 64% !important;
            }
            .row[dir="rtl"].dialogue .replicator {
                text-align: right !important;
                margin-right: 18% !important;
                margin-left: 18% !important;
                width: 64% !important;
            }
            .row[dir="rtl"].parenthetical .replicator {
                text-align: right !important;
                margin-right: 28% !important;
                margin-left: 0 !important;
                width: 44% !important;
            }
            /* Ensure LTR text containers have proper constraints - browser handles content area via @page */
            .row.scene .replicator {
                width: 100% !important;
            }
            .row.action .replicator {
                width: 100% !important;
            }
            .row.character .replicator {
                margin-left: 18% !important;
                width: 64% !important;
            }
            .row.dialogue .replicator {
                margin-left: 18% !important;
                width: 64% !important;
            }
            .row.parenthetical .replicator {
                margin-left: 28% !important;
                width: 44% !important;
            }
            .row.transition .replicator {
                width: 100% !important;
            }
            /* Ensure character, parenthetical, dialogue have tight line-height in print */
            .row.character .replicator,
            .row.parenthetical .replicator,
            .row.dialogue .replicator {
                line-height: 1.0 !important;
            }
            /* Ensure transition replicator has proper styling for consistent rendering */
            .row.transition .replicator {
                line-height: 1.1 !important;
                margin: 0 !important;
                padding: 0 !important;
            }
            /* Ensure rows and containers don't cut off content */
            .row {
                overflow: visible !important;
                height: auto !important;
                margin-bottom: 0 !important;
                padding: 0 !important;
                border: 0 !important;
                box-sizing: border-box !important;
                width: 100% !important;
            }
            .container-box {
                overflow: visible !important;
                width: 100% !important;
                box-sizing: border-box !important;
            }
            .input-grid {
                width: 100% !important;
            }
            /* Reset all row margins first, then apply specific spacing */
            .row.scene,
            .row.action,
            .row.character,
            .row.parenthetical,
            .row.dialogue,
            .row.transition {
                margin-left: 0 !important;
                margin-right: 0 !important;
                margin-bottom: 0 !important;
                padding-top: 0 !important;
                padding-bottom: 0 !important;
                padding-left: 0 !important;
                padding-right: 0 !important;
            }
            /* Explicitly set spacing for all element types in print using pt units for cross-browser consistency */
            /* First element on page */
            #page > .row:first-child,
            #page > .container-box:first-child > .row:first-child {
                margin-top: 25pt !important;
            }
            /* Scene headings - 25pt before */
            .row.scene {
                margin-top: 25pt !important;
            }
            /* Action paragraphs - 12pt before */
            .row.action {
                margin-top: 12pt !important;
                page-break-inside: auto !important;
                break-inside: auto !important;
            }
            /* Character - 12pt before */
            .row.character {
                margin-top: 12pt !important;
            }
            /* Parenthetical & Dialogue - 0 before (glued to above) */
            .row.parenthetical,
            .row.dialogue {
                margin-top: 0 !important;
            }
            /* Transition - 12pt before (same as character/action for consistent spacing) */
            /* CRITICAL: Use ::before pseudo-element to create spacing that Safari respects */
            .row.transition {
                margin-top: 0 !important;  /* Reset margin, use ::before for spacing */
                margin-bottom: 0 !important;
                padding-top: 0 !important;
                padding-bottom: 0 !important;
                display: block !important;
                clear: both !important;
                position: relative !important;
            }
            /* Use ::before to create the 12pt spacing - this works reliably in Safari */
            .row.transition::before {
                content: "" !important;
                display: block !important;
                height: 12pt !important;
                width: 100% !important;
                margin: 0 !important;
                padding: 0 !important;
                line-height: 0 !important;
                font-size: 0 !important;
            }
            /* Ensure this works for all transition contexts */
            .row.action + .row.transition::before,
            .row.dialogue + .row.transition::before,
            .row.parenthetical + .row.transition::before,
            .row.character + .row.transition::before,
            .row.scene + .row.transition::before,
            #page .row.action + .row.transition::before,
            #page .row.dialogue + .row.transition::before,
            #page .row.parenthetical + .row.transition::before,
            #page .row.character + .row.transition::before,
            #page .row.scene + .row.transition::before,
            .container-box .row.action + .row.transition::before,
            .container-box .row.dialogue + .row.transition::before,
            .container-box .row.parenthetical + .row.transition::before,
            .container-box .row.character + .row.transition::before,
            .container-box > .row.transition::before {
                content: "" !important;
                display: block !important;
                height: 12pt !important;
                width: 100% !important;
                margin: 0 !important;
                padding: 0 !important;
            }
            /* Page break control - prevent breaking dialogue/character groups */
            .row.scene {
                page-break-after: auto !important;
                page-break-inside: avoid !important;
            }
            .row.action {
                page-break-after: auto !important;
                page-break-inside: avoid !important;
                orphans: 2 !important;
                widows: 2 !important;
            }
            /* Keep character, parenthetical, and dialogue together */
            .row.character {
                page-break-after: avoid !important;
                page-break-inside: avoid !important;
            }
            .row.parenthetical {
                page-break-after: avoid !important;
                page-break-inside: avoid !important;
            }
            .row.dialogue {
                page-break-after: auto !important;
                page-break-inside: avoid !important;
                orphans: 2 !important;
                widows: 2 !important;
            }
            .row.transition {
                page-break-after: auto !important;
                page-break-inside: avoid !important;
            }
            /* Prevent breaking container groups */
            .container-box {
                page-break-inside: avoid !important;
            }
        }
    </style>
    <!-- PDF export now uses browser's native print functionality with CSS print styles -->
    <!-- Libraries for importing PDF, DOCX, and Pages files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>

<div id="floating-actions">
    <button onclick="app.clear()" title="New Document"></button>
    <button onclick="app.saveJSON()" title="Save"></button>
    <button onclick="document.getElementById('load').click()" title="Load"></button>
    <button onclick="app.exportPDF()" title="Export PDF"></button>
    <button id="theme-toggle" onclick="app.toggleTheme()" title="Toggle Light/Dark Mode"></button>
    <button onclick="app.toggleSceneMap()" title="Toggle Scene Map"></button>
    <button onclick="app.openTitlePage()" title="Title Page"></button>
</div>

<div id="selection-bar">
    <span id="sel-count" style="font-size:12px; color:#aaa; font-weight:bold;">0 Selected</span>
    <button class="primary" onclick="app.groupSelection()">Group Selection</button>
    <button style="color:#f55; border-color:#522; background:#311;" onclick="app.bulkDelete()">Delete</button>
    <button onclick="app.clearSelection()">Cancel</button>
</div>

<input type="file" id="load" style="display:none" accept=".json,.pdf,.pages,.docx" onchange="app.loadFile(this)">

<div id="scene-map">
    <div class="scene-map-header">Scenes</div>
    <input type="text" id="scene-search" placeholder="Search scenes..." />
    <div id="scene-list"></div>
</div>

<div id="title-page-modal" onclick="if(event.target.id === 'title-page-modal') app.closeTitlePage()">
    <div id="title-page-content">
        <h2>Title Page</h2>
        <div class="title-page-field">
            <label for="title-page-title">Title</label>
            <input type="text" id="title-page-title" placeholder="Screenplay Title" />
        </div>
        <div class="title-page-field">
            <label for="title-page-writer">Writer</label>
            <input type="text" id="title-page-writer" placeholder="Writer Name" />
        </div>
        <div id="title-page-custom-areas">
            <div class="title-page-custom-header">
                <label>Custom Details</label>
                <button type="button" class="add-custom-area" onclick="app.addCustomArea()" title="Add Custom Field">+</button>
            </div>
            <div id="title-page-custom-list"></div>
        </div>
        <div class="title-page-actions">
            <button class="secondary" onclick="app.closeTitlePage()">Cancel</button>
            <button class="primary" onclick="app.saveTitlePage()">Save</button>
        </div>
    </div>
</div>

<div id="workspace">
    <div id="title-page-print" style="display: none;"></div>
    <div id="page"></div>
    <div id="page-buffer" style="display: none;"></div>
</div>

<script>
    const TYPES = ['scene', 'action', 'character', 'parenthetical', 'dialogue', 'transition'];

    class Engine {
        constructor() {
            const savedData = localStorage.getItem('nvlastdraft_data');
            if (savedData) {
                const parsed = JSON.parse(savedData);
                // Handle both old format (array) and new format (object with state and titlePage)
                if (Array.isArray(parsed)) {
                    this.state = parsed;
                    this.titlePage = this.loadTitlePageFromStorage();
                } else {
                    this.state = parsed.state || [this.createBlock('scene', 'INT. START - DAY')];
                    this.titlePage = parsed.titlePage || this.getDefaultTitlePage();
                }
            } else {
                this.state = [this.createBlock('scene', 'INT. START - DAY')];
                this.titlePage = this.getDefaultTitlePage();
            }
            this.page = document.getElementById('page');
            this.pageBuffer = document.getElementById('page-buffer');
            this.selBar = document.getElementById('selection-bar');
            this.selCount = document.getElementById('sel-count');
            
            this.lastFocusedIndex = null;
            this.lastFocusedContainerIndex = null;
            this.multiSelections = []; 
            this.scenes = [];
            this.draggedSceneIndex = undefined;
            this.draggedSceneId = null;

            // Undo/Redo history
            this.history = [];
            this.historyIndex = -1;
            this.maxHistorySize = 1000; // Limit history to prevent memory issues
            this.isUndoRedo = false; // Flag to optimize rendering during undo/redo

            this.initTheme();
            this.initDragDrop();
            // Save initial state to history
            this.saveToHistory();
            this.render();
            window.addEventListener('paste', (e) => this.handlePaste(e), true);
            window.addEventListener('keydown', (e) => this.handleGlobalKey(e));
            
            // Handle clicks on empty space
            const workspace = document.getElementById('workspace');
            workspace.addEventListener('click', (e) => this.handleWorkspaceClick(e));
            
            // Close dropdowns when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.type-select-wrapper')) {
                    document.querySelectorAll('.type-select-menu.open').forEach(menu => {
                        menu.classList.remove('open');
                    });
                    document.querySelectorAll('.type-select-button.open').forEach(btn => {
                        btn.classList.remove('open');
                    });
                }
            });

            // Wire up scene search
            const sceneSearch = document.getElementById('scene-search');
            if (sceneSearch) {
                sceneSearch.addEventListener('input', (e) => {
                    this.renderSceneMap(e.target.value);
                });
            }
        }

        createBlock(type, text = '') {
            return {
                id: Math.random().toString(36).substr(2, 9),
                isContainer: false,
                type: type,
                versions: [text],
                active: 0
            };
        }

        createContainer(blocks) {
            return {
                id: Math.random().toString(36).substr(2, 9),
                isContainer: true,
                versions: [blocks],
                active: 0
            };
        }

        render(useBuffer = false) {
            if (useBuffer && this.pageBuffer) {
                // Render to hidden buffer first
                const fragment = document.createDocumentFragment();
                this.state.forEach((item, idx) => {
                    if (item.isContainer) {
                        fragment.appendChild(this.renderContainer(item, idx));
                    } else {
                        fragment.appendChild(this.renderBlock(item, idx));
                    }
                });
                
                this.pageBuffer.innerHTML = '';
                this.pageBuffer.appendChild(fragment);
                
                // Hide current page, show buffer, then swap
                this.page.style.display = 'none';
                this.pageBuffer.style.display = '';
                
                // Swap the actual DOM elements
                const workspace = document.getElementById('workspace');
                const pageParent = this.page.parentNode;
                const bufferParent = this.pageBuffer.parentNode;
                
                // Move buffer to where page is
                workspace.insertBefore(this.pageBuffer, this.page);
                // Move page to where buffer was
                workspace.insertBefore(this.page, this.pageBuffer.nextSibling);
                
                // Update references
                const temp = this.page;
                this.page = this.pageBuffer;
                this.pageBuffer = temp;
                
                // Update IDs
                this.page.id = 'page';
                this.pageBuffer.id = 'page-buffer';
                
                // Ensure correct display
                this.page.style.display = '';
                this.pageBuffer.style.display = 'none';
            } else {
                // Normal render
                const fragment = document.createDocumentFragment();
                this.state.forEach((item, idx) => {
                    if (item.isContainer) {
                        fragment.appendChild(this.renderContainer(item, idx));
                    } else {
                        fragment.appendChild(this.renderBlock(item, idx));
                    }
                });
                
                if (this.page.replaceChildren) {
                    this.page.replaceChildren(fragment);
                } else {
                    this.page.innerHTML = '';
                    this.page.appendChild(fragment);
                }
            }
            
            this.updateSelectionUI();
            
            // Skip scene map rebuild during undo/redo to eliminate jitter
            // It will rebuild on next normal render or when scene map is opened
            if (!this.isUndoRedo) {
                this.buildSceneMap();
            } else {
                // Mark that scene map needs rebuild, but don't do it now
                this.sceneMapNeedsRebuild = true;
                this.isUndoRedo = false;
            }
        }

        renderBlock(block, idx, isInsideContainer = false, containerIdx = null) {
            const row = document.createElement('div');
            row.className = `row ${block.type}`;
            row.id = isInsideContainer ? `c-${containerIdx}-b-${idx}` : `row-${idx}`;
            
            const text = block.versions[block.active];
            if (/[\u0600-\u06FF]/.test(text)) row.setAttribute('dir', 'rtl');

            if (this.isBlockSelected(idx, containerIdx)) {
                row.classList.add('multi-selected');
            }
            
            row.onmousedown = (e) => this.handleRowClick(e, idx, containerIdx);

            if (!this.isBlockSelected(idx, containerIdx)) {
                const gutter = document.createElement('div');
                gutter.className = 'gutter';
                
                // Unified container for all controls
                const gutterContainer = document.createElement('div');
                gutterContainer.className = 'gutter-container';
                
                // Custom dropdown wrapper
                const selectWrapper = document.createElement('div');
                selectWrapper.className = 'type-select-wrapper';
                
                const selectButton = document.createElement('button');
                selectButton.className = 'type-select-button';
                selectButton.type = 'button';
                const currentType = block.type.toUpperCase().substr(0,4);
                selectButton.innerHTML = currentType + '<svg class="type-select-arrow" viewBox="0 0 7 4" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1 1L3.5 3L6 1" stroke="currentColor" stroke-width="1.2" stroke-linecap="square" stroke-linejoin="miter"/></svg>';
                
                const selectMenu = document.createElement('div');
                selectMenu.className = 'type-select-menu';
                
                TYPES.forEach(t => {
                    const option = document.createElement('button');
                    option.className = 'type-select-option';
                    if(t === block.type) option.classList.add('active');
                    option.textContent = t.toUpperCase().substr(0,4);
                    option.onclick = (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        this.saveToHistory();
                        block.type = t;
                        this.save();
                        this.render();
                    };
                    
                    // Also prevent mousedown from propagating
                    option.onmousedown = (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                    };
                    selectMenu.appendChild(option);
                });
                
                selectButton.onclick = (e) => {
                    e.stopPropagation();
                    const isOpen = selectMenu.classList.contains('open');
                    // Close all other dropdowns
                    document.querySelectorAll('.type-select-menu.open').forEach(menu => {
                        if(menu !== selectMenu) menu.classList.remove('open');
                    });
                    document.querySelectorAll('.type-select-button.open').forEach(btn => {
                        if(btn !== selectButton) btn.classList.remove('open');
                    });
                    // Toggle this dropdown
                    selectMenu.classList.toggle('open', !isOpen);
                    selectButton.classList.toggle('open', !isOpen);
                    
                    // Add/remove class to body to help with CSS targeting
                    if (!isOpen) {
                        document.body.classList.add('dropdown-open');
                    } else {
                        document.body.classList.remove('dropdown-open');
                    }
                };
                
                // Prevent mousedown events from propagating to row
                selectButton.onmousedown = (e) => {
                    e.stopPropagation();
                };
                
                // Prevent mousedown events on the menu from propagating
                selectMenu.onmousedown = (e) => {
                    e.stopPropagation();
                };
                
                // When dropdown closes, remove body class
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (!selectMenu.classList.contains('open') && document.body.classList.contains('dropdown-open')) {
                            // Check if any dropdown is still open
                            if (document.querySelectorAll('.type-select-menu.open').length === 0) {
                                document.body.classList.remove('dropdown-open');
                            }
                        }
                    });
                });
                observer.observe(selectMenu, { attributes: true, attributeFilter: ['class'] });
                
                selectWrapper.appendChild(selectButton);
                selectWrapper.appendChild(selectMenu);
                gutterContainer.appendChild(selectWrapper);

                const versionControls = document.createElement('div');
                versionControls.className = 'version-controls';
                
                const prevBtn = document.createElement('button');
                prevBtn.textContent = '';
                prevBtn.onclick = () => app.blockVer(block.id, -1);
                prevBtn.title = 'Previous version';
                
                const versionNum = document.createElement('span');
                versionNum.className = 'version-number';
                versionNum.textContent = block.active + 1;
                
                const nextBtn = document.createElement('button');
                nextBtn.textContent = '';
                nextBtn.onclick = () => app.blockVer(block.id, 1);
                nextBtn.title = 'Next version';
                
                const addBtn = document.createElement('button');
                addBtn.className = 'add-version-btn';
                addBtn.textContent = '+';
                addBtn.onclick = () => app.addBlockVer(block.id);
                addBtn.title = 'New version';
                
                versionControls.appendChild(prevBtn);
                versionControls.appendChild(versionNum);
                versionControls.appendChild(nextBtn);
                versionControls.appendChild(addBtn);
                gutterContainer.appendChild(versionControls);
                
                gutter.appendChild(gutterContainer);
                row.appendChild(gutter);
            }

            const grid = document.createElement('div');
            grid.className = 'input-grid';
            
            const replicator = document.createElement('div');
            replicator.className = 'replicator';
            replicator.innerHTML = this.parseMarkdown(text) + '\u200B';

            const ta = document.createElement('textarea');
            ta.value = text;
            ta.id = isInsideContainer ? `in-c-${containerIdx}-b-${idx}` : `in-row-${idx}`;
            
            // Function to sync textarea height with replicator
            const syncHeight = () => {
                ta.style.height = 'auto';
                ta.style.height = replicator.scrollHeight + 'px';
            };
            
            // Track editing state - save on blur (when user moves to something else)
            let editStartValue = text;
            let hasSavedForThisEdit = false;
            
            ta.onfocus = () => {
                // When focusing, save the state BEFORE any changes (so we can undo to this point)
                // But only if we haven't already saved for this focus session
                if (!hasSavedForThisEdit) {
                    editStartValue = ta.value;
                    // Don't save on focus - wait until they actually change something or blur
                }
            };
            
            ta.oninput = (e) => {
                const newValue = e.target.value;
                block.versions[block.active] = newValue;
                
                // Save history ONLY on first change of this edit session
                if (!hasSavedForThisEdit && newValue !== editStartValue) {
                    this.saveToHistory();
                    hasSavedForThisEdit = true;
                }
                
                // Check if there's an active search to maintain highlights
                const sceneSearch = document.getElementById('scene-search');
                const searchTerm = sceneSearch ? sceneSearch.value.trim() : '';
                if (searchTerm) {
                    // Re-apply highlights
                    this.highlightSearchTerm(searchTerm.toLowerCase());
                } else {
                    // No search, just update text with markdown parsing
                    replicator.innerHTML = this.parseMarkdown(newValue) + '\u200B';
                }
                if (/[\u0600-\u06FF]/.test(newValue)) row.setAttribute('dir', 'rtl');
                else row.removeAttribute('dir');
                syncHeight();
                this.save();
                // Rebuild scene map to update content
                this.buildSceneMap();
            };
            
            // When user stops editing (blur), save if they made changes
            // This creates a new undo step when they move to something else
            ta.onblur = () => {
                // Update replicator with formatted text when blurring
                const sceneSearch = document.getElementById('scene-search');
                const searchTerm = sceneSearch ? sceneSearch.value.trim() : '';
                if (!searchTerm) {
                    replicator.innerHTML = this.parseMarkdown(ta.value) + '\u200B';
                }
                
                if (hasSavedForThisEdit && ta.value !== editStartValue) {
                    // Value changed, save final state (this will be the state after the edit)
                    // But only if it's different from what we already saved
                    const currentStateStr = JSON.stringify(this.state);
                    if (this.history.length > 0 && this.historyIndex >= 0) {
                        const lastStateStr = JSON.stringify(this.history[this.historyIndex]);
                        if (currentStateStr !== lastStateStr) {
                            this.saveToHistory();
                        }
                    }
                }
                // Reset for next time
                hasSavedForThisEdit = false;
            };
            
            // Initial height sync
            setTimeout(syncHeight, 0);
            
            ta.onkeydown = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.handleEnter(block, idx, isInsideContainer, containerIdx);
                }
                if (e.key === 'Backspace') {
                    if (ta.value === '') {
                        if(this.multiSelections.length === 0) {
                            e.preventDefault();
                            this.handleDelete(block, idx, isInsideContainer, containerIdx);
                        }
                    }
                }
            };
            
            ta.onfocus = (e) => {
                if (!e.shiftKey) {
                    this.lastFocusedIndex = idx;
                    this.lastFocusedContainerIndex = containerIdx;
                    if (this.multiSelections.length > 0) {
                        this.clearSelection();
                    }
                }
            };

            grid.appendChild(replicator);
            grid.appendChild(ta);
            row.appendChild(grid);
            return row;
        }

        renderContainer(container, idx) {
            const box = document.createElement('div');
            box.className = 'container-box';
            
            const header = document.createElement('div');
            header.className = 'container-header';
            
            const controls = document.createElement('div');
            controls.className = 'container-version-controls';
            
            const prevBtn = document.createElement('button');
            prevBtn.className = 'container-version-btn container-version-nav';
            prevBtn.textContent = '';
            prevBtn.onclick = () => app.containerVer(idx, -1);
            prevBtn.title = 'Previous version';
            
            const versionNum = document.createElement('span');
            versionNum.className = 'container-version-number';
            versionNum.textContent = `v${container.active + 1}`;
            
            const nextBtn = document.createElement('button');
            nextBtn.className = 'container-version-btn container-version-nav';
            nextBtn.textContent = '';
            nextBtn.onclick = () => app.containerVer(idx, 1);
            nextBtn.title = 'Next version';
            
            const addBtn = document.createElement('button');
            addBtn.className = 'container-version-btn container-add-btn';
            addBtn.textContent = '+';
            addBtn.onclick = () => app.addContainerVer(idx);
            addBtn.title = 'New version';
            
            const ungroupBtn = document.createElement('button');
            ungroupBtn.className = 'container-version-btn container-ungroup-btn';
            ungroupBtn.textContent = 'Ungroup';
            ungroupBtn.onclick = () => app.ungroup(idx);
            ungroupBtn.title = 'Ungroup elements';
            
            controls.appendChild(prevBtn);
            controls.appendChild(versionNum);
            controls.appendChild(nextBtn);
            controls.appendChild(addBtn);
            controls.appendChild(ungroupBtn);
            
            header.appendChild(controls);
            box.appendChild(header);

            const activeBlocks = container.versions[container.active];
            if(activeBlocks.length === 0) {
                 const empty = document.createElement('div');
                 empty.innerText = "(Empty Group - Click to Add)";
                 empty.style.color="#555"; empty.style.fontSize="12px"; empty.style.cursor="pointer";
                 empty.onclick = () => {
                     activeBlocks.push(this.createBlock('action'));
                     this.save(); this.render();
                 }
                 box.appendChild(empty);
            } else {
                activeBlocks.forEach((b, bIdx) => {
                    box.appendChild(this.renderBlock(b, bIdx, true, idx));
                });
            }
            return box;
        }

        // --- SELECTION LOGIC ---

        handleRowClick(e, idx, containerIdx) {
            // Ignore clicks that originate from dropdown menus
            if (e.target.closest('.type-select-menu') || 
                e.target.closest('.type-select-option') ||
                e.target.closest('.type-select-wrapper')) {
                return;
            }
            
            const sameContext = (this.lastFocusedContainerIndex === containerIdx);
            
            if (e.shiftKey && this.lastFocusedIndex !== null && sameContext) {
                e.preventDefault();
                const start = Math.min(this.lastFocusedIndex, idx);
                const end = Math.max(this.lastFocusedIndex, idx);
                this.multiSelections = [];
                for(let i = start; i <= end; i++) this.multiSelections.push(i);
                this.render();
            }
        }

        updateSelectionUI() {
            if (this.multiSelections.length > 0) {
                this.selBar.classList.add('visible');
                this.selCount.innerText = `${this.multiSelections.length} Selected`;
            } else {
                this.selBar.classList.remove('visible');
            }
        }

        clearSelection() {
            this.multiSelections = [];
            this.render();
        }

        isBlockSelected(idx, containerIdx) {
            if (this.multiSelections.length === 0) return false;
            if (this.lastFocusedContainerIndex !== containerIdx) return false;
            return this.multiSelections.includes(idx);
        }

        // --- GROUP & DELETE ---

        groupSelection() {
            if (this.multiSelections.length === 0) return;
            const cIdx = this.lastFocusedContainerIndex;
            
            if (cIdx !== null) {
                alert("You are already inside a group. Nested grouping not supported.");
                return;
            }

            // Save history before operation
            this.saveToHistory();
            
            this.multiSelections.sort((a,b) => a-b);
            const first = this.multiSelections[0];
            const count = this.multiSelections.length;
            
            const extracted = this.state.splice(first, count);
            const hasContainer = extracted.some(i => i.isContainer);
            if(hasContainer) {
                alert("Cannot group existing groups.");
                this.state.splice(first, 0, ...extracted); 
                // Operation failed, remove the history entry we just added
                this.history.pop();
                this.historyIndex--;
                return;
            }

            const container = this.createContainer(extracted);
            this.state.splice(first, 0, container);
            
            this.clearSelection();
            this.save(); 
            this.render();
            
            // Update history with final state to ensure it's correct
            this.history[this.historyIndex] = JSON.parse(JSON.stringify(this.state));
        }

        bulkDelete() {
            if (this.multiSelections.length === 0) return;
            this.saveToHistory();
            const cIdx = this.lastFocusedContainerIndex;
            this.multiSelections.sort((a,b) => b-a); 

            if (cIdx !== null) {
                const blocks = this.state[cIdx].versions[this.state[cIdx].active];
                // Don't delete all blocks in a container
                if (this.multiSelections.length >= blocks.length) {
                    return;
                }
                this.multiSelections.forEach(idx => {
                    if (idx < blocks.length) blocks.splice(idx, 1);
                });
            } else {
                // Ensure at least one block remains
                if (this.multiSelections.length >= this.state.length) {
                    // If trying to delete all, keep one and clear it
                    this.state = [this.createBlock('scene', '')];
                } else {
                    this.multiSelections.forEach(idx => {
                        if (idx < this.state.length) this.state.splice(idx, 1);
                    });
                }
            }

            this.clearSelection();
            this.save(); this.render();
            
            // Focus the remaining block
            if (this.state.length > 0) {
                if (cIdx !== null) {
                    const blocks = this.state[cIdx].versions[this.state[cIdx].active];
                    if (blocks.length > 0) {
                        this.focus(true, cIdx, blocks.length - 1);
                    }
                } else {
                    this.focus(false, null, this.state.length - 1);
                }
            }
        }

        handleGlobalKey(e) {
            // Handle Save (Cmd+S or Ctrl+S)
            if ((e.metaKey || e.ctrlKey) && (e.key === 's' || e.key === 'S') && !e.shiftKey) {
                e.preventDefault();
                this.saveJSON();
                return;
            }
            
            // Handle Export PDF (Shift+Cmd+S or Ctrl+Shift+S)
            if ((e.metaKey || e.ctrlKey) && (e.key === 's' || e.key === 'S') && e.shiftKey) {
                e.preventDefault();
                this.exportPDF();
                return;
            }
            
            // Handle Undo (Cmd+Z or Ctrl+Z)
            if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                this.undo();
                return;
            }
            
            // Handle Redo (Shift+Cmd+Z or Ctrl+Shift+Z)
            if ((e.metaKey || e.ctrlKey) && (e.key === 'z' || e.key === 'Z') && e.shiftKey) {
                e.preventDefault();
                this.redo();
                return;
            }
            
            // Handle Scene Map Toggle (Cmd+K or Ctrl+K)
            if ((e.metaKey || e.ctrlKey) && (e.key === 'k' || e.key === 'K') && !e.shiftKey) {
                e.preventDefault();
                this.toggleSceneMap();
                return;
            }
            
            // Handle Bold (Cmd+B or Ctrl+B)
            if ((e.metaKey || e.ctrlKey) && (e.key === 'b' || e.key === 'B')) {
                const activeElement = document.activeElement;
                if (activeElement && activeElement.tagName === 'TEXTAREA') {
                    e.preventDefault();
                    this.wrapSelectionWithFormatting(activeElement, '**', '**');
                    return;
                }
            }
            
            // Handle Italic (Cmd+I or Ctrl+I)
            if ((e.metaKey || e.ctrlKey) && (e.key === 'i' || e.key === 'I')) {
                const activeElement = document.activeElement;
                if (activeElement && activeElement.tagName === 'TEXTAREA') {
                    e.preventDefault();
                    this.wrapSelectionWithFormatting(activeElement, '*', '*');
                    return;
                }
            }
            
            if ((e.key === 'Backspace' || e.key === 'Delete') && this.multiSelections.length > 0) {
                e.preventDefault();
                this.bulkDelete();
            }
            
            // Handle Cmd+1 through Cmd+6 for block type changes
            if ((e.metaKey || e.ctrlKey) && e.key >= '1' && e.key <= '6') {
                e.preventDefault();
                const typeMap = {
                    '1': 'scene',
                    '2': 'action',
                    '3': 'character',
                    '4': 'parenthetical',
                    '5': 'dialogue',
                    '6': 'transition'
                };
                const newType = typeMap[e.key];
                if (newType) {
                    this.changeBlockType(newType);
                }
            }
        }

        wrapSelectionWithFormatting(textarea, prefix, suffix) {
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const selectedText = textarea.value.substring(start, end);
            
            // If no text is selected, just insert the formatting markers
            if (selectedText.length === 0) {
                const newText = prefix + suffix;
                textarea.value = textarea.value.substring(0, start) + newText + textarea.value.substring(end);
                textarea.selectionStart = textarea.selectionEnd = start + prefix.length;
            } else {
                // Check if the selected text is already wrapped with this formatting
                const isAlreadyWrapped = 
                    textarea.value.substring(Math.max(0, start - prefix.length), start) === prefix &&
                    textarea.value.substring(end, Math.min(textarea.value.length, end + suffix.length)) === suffix;
                
                if (isAlreadyWrapped) {
                    // Remove formatting
                    textarea.value = 
                        textarea.value.substring(0, start - prefix.length) + 
                        selectedText + 
                        textarea.value.substring(end + suffix.length);
                    textarea.selectionStart = start - prefix.length;
                    textarea.selectionEnd = end - prefix.length;
                } else {
                    // Add formatting
                    const newText = prefix + selectedText + suffix;
                    textarea.value = textarea.value.substring(0, start) + newText + textarea.value.substring(end);
                    textarea.selectionStart = start;
                    textarea.selectionEnd = start + newText.length;
                }
            }
            
            // Trigger input event to update the replicator and save state
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Save to history for undo/redo
            this.saveToHistory();
        }

        // Parse markdown formatting (**bold** and *italic*) to HTML
        parseMarkdown(text) {
            if (!text) return '';
            
            // Escape HTML to prevent XSS
            let html = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            
            // Process bold (**text** or __text__) - must be at least one character
            html = html.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/__([^_]+?)__/g, '<strong>$1</strong>');
            
            // Process italic (*text* or _text_) - but not if it's part of **
            // Match single * that are not part of **
            html = html.replace(/(?<!\*)\*([^*\n]+?)\*(?!\*)/g, '<em>$1</em>');
            // Match single _ that are not part of __
            html = html.replace(/(?<!_)_([^_\n]+?)_(?!_)/g, '<em>$1</em>');
            
            return html;
        }

        // --- STANDARD OPERATIONS ---

        handleEnter(block, idx, inside, cIdx) {
            this.saveToHistory();
            let next = 'action';
            if (block.type === 'character') next = 'dialogue';
            if (block.type === 'parenthetical') next = 'dialogue';
            if (block.type === 'transition') next = 'scene';

            const newBlock = this.createBlock(next);
            if (inside) {
                this.state[cIdx].versions[this.state[cIdx].active].splice(idx + 1, 0, newBlock);
                this.save(); this.render();
                this.focus(true, cIdx, idx + 1);
            } else {
                this.state.splice(idx + 1, 0, newBlock);
                this.save(); this.render();
                this.focus(false, null, idx + 1);
            }
        }

        handleDelete(block, idx, inside, cIdx) {
            this.saveToHistory();
            if (inside) {
                const blocks = this.state[cIdx].versions[this.state[cIdx].active];
                if (blocks.length > 1) {
                    blocks.splice(idx, 1);
                    this.save(); this.render();
                    this.focus(true, cIdx, idx - 1);
                } else if (blocks.length === 1) {
                    // If last block in container, clear it instead of deleting
                    blocks[0].versions[blocks[0].active] = '';
                    this.save(); this.render();
                    this.focus(true, cIdx, 0);
                }
            } else {
                if (this.state.length > 1) {
                    this.state.splice(idx, 1);
                    this.save(); this.render();
                    this.focus(false, null, idx - 1);
                } else if (this.state.length === 1) {
                    // If last block, clear it instead of deleting
                    this.state[0].versions[this.state[0].active] = '';
                    this.save(); this.render();
                    this.focus(false, null, 0);
                }
            }
        }

        focus(inside, cIdx, bIdx) {
            setTimeout(() => {
                let id = inside ? `in-c-${cIdx}-b-${bIdx}` : `in-row-${bIdx}`;
                if (bIdx < 0) {
                    id = inside ? `in-c-${cIdx}-b-0` : `in-row-0`;
                }
                const el = document.getElementById(id);
                if(el) {
                    el.focus();
                    el.setSelectionRange(el.value.length, el.value.length);
                }
            }, 10);
        }

        handleWorkspaceClick(e) {
            // Close all dropdowns when clicking outside
            if (!e.target.closest('.type-select-wrapper')) {
                document.querySelectorAll('.type-select-menu.open').forEach(menu => {
                    menu.classList.remove('open');
                });
                document.querySelectorAll('.type-select-button.open').forEach(btn => {
                    btn.classList.remove('open');
                });
            }
            // Don't handle if clicking on a block, textarea, button, or other interactive element
            const target = e.target;
            if (target.tagName === 'TEXTAREA' || 
                target.tagName === 'BUTTON' || 
                target.tagName === 'SELECT' ||
                target.closest('.row') ||
                target.closest('.container-box') ||
                target.closest('#floating-actions') ||
                target.closest('#selection-bar') ||
                target.closest('.type-select-wrapper')) {
                return;
            }

            // If page is empty, create a new block
            if (this.state.length === 0) {
                this.state = [this.createBlock('scene', '')];
                this.save();
                this.render();
                this.focus(false, null, 0);
                return;
            }

            // Check if click is inside the page element
            const pageRect = this.page.getBoundingClientRect();
            const clickY = e.clientY;
            const clickX = e.clientX;
            
            const isInsidePage = clickX >= pageRect.left && 
                                clickX <= pageRect.right && 
                                clickY >= pageRect.top && 
                                clickY <= pageRect.bottom;

            if (isInsidePage) {
                // Find the closest block to the click position
                const allRows = this.page.querySelectorAll('.row');
                let closestRow = null;
                let closestDistance = Infinity;

                allRows.forEach(row => {
                    const rowRect = row.getBoundingClientRect();
                    // Calculate distance from click to center of row
                    const rowCenterY = rowRect.top + rowRect.height / 2;
                    const rowCenterX = rowRect.left + rowRect.width / 2;
                    const distance = Math.sqrt(
                        Math.pow(clickX - rowCenterX, 2) + 
                        Math.pow(clickY - rowCenterY, 2)
                    );

                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestRow = row;
                    }
                });

                if (closestRow) {
                    const rowId = closestRow.id;
                    // Parse the row ID to determine if it's a container block or top-level block
                    if (rowId.startsWith('c-')) {
                        // Block inside container: format is c-{containerIdx}-b-{blockIdx}
                        const match = rowId.match(/^c-(\d+)-b-(\d+)$/);
                        if (match) {
                            const containerIdx = parseInt(match[1]);
                            const blockIdx = parseInt(match[2]);
                            this.focus(true, containerIdx, blockIdx);
                            return;
                        }
                    } else if (rowId.startsWith('row-')) {
                        // Top-level block: format is row-{idx}
                        const match = rowId.match(/^row-(\d+)$/);
                        if (match) {
                            const blockIdx = parseInt(match[1]);
                            this.focus(false, null, blockIdx);
                            return;
                        }
                    }
                }
            }

            // If click is outside page or no closest row found, focus on last block
            let lastIdx = this.state.length - 1;
            let lastItem = this.state[lastIdx];
            
            // If last item is a container, find the last block inside it
            if (lastItem.isContainer) {
                const blocks = lastItem.versions[lastItem.active];
                if (blocks.length > 0) {
                    const lastBlockIdx = blocks.length - 1;
                    this.focus(true, lastIdx, lastBlockIdx);
                    return;
                }
            }
            
            // Otherwise focus the last top-level block
            this.focus(false, null, lastIdx);
        }

        // --- BLOCK TYPE CHANGE ---
        changeBlockType(newType) {
            // Don't change type if no block is focused
            if (this.lastFocusedIndex === null) return;
            
            this.saveToHistory();
            const idx = this.lastFocusedIndex;
            const containerIdx = this.lastFocusedContainerIndex;
            
            if (containerIdx !== null) {
                // Block is inside a container
                const container = this.state[containerIdx];
                const blocks = container.versions[container.active];
                if (idx < blocks.length) {
                    blocks[idx].type = newType;
                    this.save();
                    this.render();
                    // Refocus the textarea after render
                    this.focus(true, containerIdx, idx);
                }
            } else {
                // Top-level block
                if (idx < this.state.length && !this.state[idx].isContainer) {
                    this.state[idx].type = newType;
                    this.save();
                    this.render();
                    // Refocus the textarea after render
                    this.focus(false, null, idx);
                }
            }
        }

        // --- UTILS ---
        findBlockById(id) {
            for (let i=0; i<this.state.length; i++) {
                if(this.state[i].id === id) return { parent: this.state, idx: i, item: this.state[i] };
                if(this.state[i].isContainer) {
                    const c = this.state[i];
                    const blocks = c.versions[c.active];
                    for (let j=0; j<blocks.length; j++) {
                        if(blocks[j].id === id) return { parent: blocks, idx: j, item: blocks[j] };
                    }
                }
            }
            return null;
        }

        blockVer(id, dir) {
            const res = this.findBlockById(id);
            if(!res) return;
            this.saveToHistory();
            let n = res.item.active + dir;
            if(n < 0) n = res.item.versions.length-1;
            if(n >= res.item.versions.length) n = 0;
            res.item.active = n;
            this.save(); 
            // Update version number display without full render
            this.updateVersionDisplay(id, res.item.active + 1);
            this.render();
        }

        addBlockVer(id) {
            const res = this.findBlockById(id);
            if(!res) return;
            this.saveToHistory();
            res.item.versions.push(res.item.versions[res.item.active]);
            res.item.active = res.item.versions.length-1;
            this.save(); 
            // Update version number display without full render
            this.updateVersionDisplay(id, res.item.active + 1);
            this.render();
        }

        updateVersionDisplay(blockId, versionNum) {
            // Find the row with this block and update version number
            const rows = this.page.querySelectorAll('.row');
            for (const row of rows) {
                const textarea = row.querySelector('textarea');
                if (textarea) {
                    // Find block by checking if this row's block matches
                    const rowId = row.id;
                    if (rowId.startsWith('row-')) {
                        const idx = parseInt(rowId.replace('row-', ''));
                        if (idx < this.state.length && this.state[idx].id === blockId) {
                            const versionNumEl = row.querySelector('.version-number');
                            if (versionNumEl) {
                                versionNumEl.textContent = versionNum;
                            }
                            return;
                        }
                    }
                }
            }
        }

        containerVer(idx, dir) {
            const c = this.state[idx];
            this.saveToHistory();
            let n = c.active + dir;
            if(n < 0) n = c.versions.length-1;
            if(n >= c.versions.length) n = 0;
            c.active = n;
            this.save(); this.render();
        }

        addContainerVer(idx) {
            const c = this.state[idx];
            // Save history before operation
            this.saveToHistory();
            
            const clone = JSON.parse(JSON.stringify(c.versions[c.active]));
            clone.forEach(b => b.id = Math.random().toString(36).substr(2, 9));
            c.versions.push(clone);
            c.active = c.versions.length - 1;
            this.save(); 
            this.render();
            
            // Update history with final state (skip duplicate check since we know it changed)
            this.saveToHistory(true);
        }

        ungroup(idx) {
            if(!confirm("Ungroup?")) return;
            this.saveToHistory();
            const c = this.state[idx];
            const blocks = c.versions[c.active];
            this.state.splice(idx, 1, ...blocks);
            this.save(); this.render();
        }

        handlePaste(e) {
            const isTextArea = e.target.tagName === 'TEXTAREA';
            const text = (e.clipboardData).getData('text');
            if(isTextArea && !text.includes('\n') && text.length < 100) return;

            e.preventDefault(); e.stopPropagation();

            this.saveToHistory();
            const lines = text.split(/\r?\n/);
            const blocks = [];
            
            for(let i=0; i<lines.length; i++) {
                const line = lines[i].trim();
                if(!line) continue;
                let type = 'action';
                
                if (/^(INT\.|EXT\.|EST\.|I\/E)/i.test(line) || line.includes('')) type = 'scene';
                else if (/TO:$/i.test(line)) type = 'transition';
                else if (line.startsWith('(')) type = 'parenthetical';
                else if (line.length < 50) {
                    if (i+1 < lines.length && lines[i+1].trim().length > 0) type = 'character';
                }
                
                if (blocks.length > 0 && blocks[blocks.length-1].type === 'character') {
                     if (type !== 'parenthetical') type = 'dialogue';
                }
                blocks.push(this.createBlock(type, line));
            }
            this.state.push(...blocks);
            this.save(); this.render();
        }

        getDefaultTitlePage() {
            return {
                title: '',
                writer: '',
                customAreas: []
            };
        }

        loadTitlePageFromStorage() {
            const saved = localStorage.getItem('nvlastdraft_titlepage');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    // Migrate old format to new format
                    if (parsed.author || parsed.contact || parsed.copyright) {
                        const customAreas = [];
                        if (parsed.contact) customAreas.push(parsed.contact);
                        if (parsed.copyright) customAreas.push(parsed.copyright);
                        return {
                            title: parsed.title || '',
                            writer: parsed.author || parsed.writer || '',
                            customAreas: customAreas
                        };
                    }
                    // If it already has customAreas, return as is
                    if (parsed.customAreas !== undefined) {
                        return parsed;
                    }
                    // Otherwise return default
                    return this.getDefaultTitlePage();
                } catch (e) {
                    return this.getDefaultTitlePage();
                }
            }
            return this.getDefaultTitlePage();
        }

        save() { 
            // Save state and titlePage together
            const dataToSave = {
                state: this.state,
                titlePage: this.titlePage
            };
            localStorage.setItem('nvlastdraft_data', JSON.stringify(dataToSave));
            // Also save titlePage separately for backward compatibility
            localStorage.setItem('nvlastdraft_titlepage', JSON.stringify(this.titlePage));
        }

        // --- UNDO/REDO ---

        saveToHistory(force = false) {
            // Deep clone the state
            const stateSnapshot = JSON.parse(JSON.stringify(this.state));
            const currentStateStr = JSON.stringify(stateSnapshot);
            
            // Only check for duplicates if not forced (for operations that we know changed)
            if (!force && this.history.length > 0 && this.historyIndex >= 0) {
                const lastStateStr = JSON.stringify(this.history[this.historyIndex]);
                if (lastStateStr === currentStateStr) {
                    // State hasn't changed, don't create duplicate history entry
                    return;
                }
            }
            
            // Remove any future history if we're not at the end
            if (this.historyIndex < this.history.length - 1) {
                this.history = this.history.slice(0, this.historyIndex + 1);
            }
            
            // Add new state to history
            this.history.push(stateSnapshot);
            this.historyIndex++;
            
            // Limit history size
            if (this.history.length > this.maxHistorySize) {
                this.history.shift();
                this.historyIndex--;
            }
        }

        undo() {
            if (this.historyIndex > 0) {
                this.isUndoRedo = true;
                this.historyIndex--;
                const restoredState = JSON.parse(JSON.stringify(this.history[this.historyIndex]));
                this.state = restoredState;
                this.save();
                // Render to buffer first, then swap (eliminates jitter)
                this.render(true);
            }
        }

        redo() {
            if (this.historyIndex < this.history.length - 1) {
                this.isUndoRedo = true;
                this.historyIndex++;
                const restoredState = JSON.parse(JSON.stringify(this.history[this.historyIndex]));
                this.state = restoredState;
                this.save();
                // Render to buffer first, then swap (eliminates jitter)
                this.render(true);
            }
        }
        clear() { 
            if(confirm('Clear all?')) { 
                this.saveToHistory();
                this.state = [this.createBlock('scene')]; 
                this.save(); 
                this.render(); 
            } 
        }
        saveJSON() {
             const dataToSave = {
                 state: this.state,
                 titlePage: this.titlePage
             };
             
             // Get the title from title page for filename
             let fileName = 'project.json';
             if (this.titlePage && this.titlePage.title && this.titlePage.title.trim()) {
                 let title = this.titlePage.title.trim();
                 // Clean the title for use as filename (remove quotes, special chars)
                 title = title.replace(/^["']|["']$/g, '').trim();
                 // Replace invalid filename characters
                 title = title.replace(/[<>:"/\\|?*]/g, '');
                 // Limit length
                 if (title.length > 100) {
                     title = title.substring(0, 100);
                 }
                 if (title.length > 0) {
                     fileName = title + '.json';
                 }
             }
             
             const a = document.createElement('a');
             a.href = URL.createObjectURL(new Blob([JSON.stringify(dataToSave, null, 2)],{type:'application/json'}));
             a.download = fileName;
             a.click();
        }
        loadJSON(inp) {
            const r = new FileReader();
            r.onload = e => { 
                const loaded = JSON.parse(e.target.result);
                // Handle both old format (array) and new format (object)
                if (Array.isArray(loaded)) {
                    this.state = loaded;
                    // Keep existing titlePage if loading old format
                } else {
                    this.state = loaded.state || [];
                    this.titlePage = loaded.titlePage || this.getDefaultTitlePage();
                }
                this.save(); 
                this.render(); 
            };
            if(inp.files[0]) r.readAsText(inp.files[0]);
        }

        // Parse screenplay text into blocks (reusable method)
        parseScreenplayText(text) {
            const lines = text.split(/\r?\n/);
            const blocks = [];
            
            for(let i=0; i<lines.length; i++) {
                const line = lines[i].trim();
                if(!line) continue;
                
                let type = 'action';
                const prevBlock = blocks.length > 0 ? blocks[blocks.length-1] : null;
                const nextLine = i+1 < lines.length ? lines[i+1].trim() : '';
                
                // Scene headings: INT., EXT., EST., I/E, INT/EXT
                if (/^(INT\.|EXT\.|EST\.|I\/E|INT\/EXT\.|INTERIOR|EXTERIOR)/i.test(line) || 
                    /^(INT|EXT)\s/i.test(line) || 
                    line.includes('')) {
                    type = 'scene';
                }
                // Transitions: FADE TO:, CUT TO:, DISSOLVE TO:, etc. (usually right-aligned in scripts)
                else if (/TO:$/i.test(line) || 
                         /^(FADE|CUT|DISSOLVE|SMASH|WIPE|IRIS|MATCH)\s+(TO|IN|OUT|BLACK)/i.test(line) ||
                         /^(FADE|CUT|DISSOLVE|SMASH|WIPE|IRIS|MATCH):$/i.test(line)) {
                    type = 'transition';
                }
                // Parentheticals: lines starting with ( and usually ending with )
                else if (line.startsWith('(') || (line.startsWith('(') && line.includes(')'))) {
                    type = 'parenthetical';
                }
                // Character names: 
                // - Usually ALL CAPS or Title Case
                // - Short lines (typically < 50 chars, often < 35)
                // - Not scene headings or transitions
                // - Followed by dialogue (not action)
                else if (line.length < 50 && 
                        (line === line.toUpperCase() || /^[A-Z][a-z]+(\s+[A-Z][a-z]+)*$/.test(line)) &&
                        !line.includes('.') && 
                        !/^(INT\.|EXT\.|EST\.|I\/E|FADE|CUT|DISSOLVE)/i.test(line)) {
                    // Check if next line looks like dialogue (not action, scene, or transition)
                    if (nextLine && 
                        nextLine.length > 0 && 
                        !nextLine.startsWith('(') &&
                        !/^(INT\.|EXT\.|EST\.|I\/E|TO:|FADE|CUT|DISSOLVE)/i.test(nextLine) &&
                        !(nextLine === nextLine.toUpperCase() && nextLine.length < 50)) {
                        type = 'character';
                    }
                }
                
                // Dialogue: follows character name or parenthetical
                if (prevBlock && (prevBlock.type === 'character' || prevBlock.type === 'parenthetical')) {
                    if (type === 'action' && 
                        !line.startsWith('(') && 
                        !/^(INT\.|EXT\.|EST\.|I\/E|TO:|FADE|CUT|DISSOLVE)/i.test(line) &&
                        !(line === line.toUpperCase() && line.length < 50 && !line.includes('.'))) {
                        type = 'dialogue';
                    }
                }
                
                // If we're in a dialogue block and encounter a parenthetical, keep it as parenthetical
                if (prevBlock && prevBlock.type === 'dialogue' && line.startsWith('(')) {
                    type = 'parenthetical';
                }
                
                // If parenthetical is followed by more text, it's likely dialogue
                if (prevBlock && prevBlock.type === 'parenthetical' && type === 'action') {
                    if (!line.startsWith('(') && 
                        !/^(INT\.|EXT\.|EST\.|I\/E|TO:|FADE|CUT|DISSOLVE)/i.test(line) &&
                        !(line === line.toUpperCase() && line.length < 50)) {
                        type = 'dialogue';
                    }
                }
                
                blocks.push(this.createBlock(type, line));
            }
            return blocks;
        }

        // Main file loader - routes to appropriate parser
        async loadFile(inp) {
            if (!inp.files || !inp.files[0]) return;
            
            const file = inp.files[0];
            const fileName = file.name.toLowerCase();
            
            this.saveToHistory();
            
            try {
                if (fileName.endsWith('.json')) {
                    this.loadJSON(inp);
                } else if (fileName.endsWith('.pdf')) {
                    await this.loadPDF(file);
                } else if (fileName.endsWith('.docx')) {
                    await this.loadDOCX(file);
                } else if (fileName.endsWith('.pages')) {
                    await this.loadPages(file);
                } else {
                    alert('Unsupported file type. Please use .json, .pdf, .docx, or .pages files.');
                }
            } catch (error) {
                console.error('Error loading file:', error);
                alert('Error loading file: ' + error.message);
            }
        }

        // Load PDF file
        async loadPDF(file) {
            try {
                // Check if pdfjsLib is loaded
                if (typeof pdfjsLib === 'undefined') {
                    throw new Error('PDF.js library not loaded. Please refresh the page.');
                }
                
                // Set up PDF.js worker
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
                
                const arrayBuffer = await file.arrayBuffer();
                const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
                const pdf = await loadingTask.promise;
                
                let fullText = '';
                
                // Extract text from all pages with improved paragraph detection
                for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                    const page = await pdf.getPage(pageNum);
                    const textContent = await page.getTextContent();
                    const viewport = page.getViewport({ scale: 1.0 });
                    
                    // Group text items by line (Y position)
                    const lines = [];
                    const yTolerance = 2; // Pixels - items within this Y distance are on the same line
                    
                    for (const item of textContent.items) {
                        if (!item.str || item.str.trim() === '') continue;
                        
                        const y = item.transform[5];
                        const x = item.transform[4];
                        
                        // Check transform matrix for direction hints
                        // transform[0] is horizontal scale, transform[1] is horizontal skew
                        // Negative horizontal scale indicates RTL
                        const transform = item.transform;
                        const isRTLItem = transform[0] < 0 || /[\u0600-\u06FF]/.test(item.str);
                        
                        // Find existing line with similar Y position
                        let foundLine = null;
                        for (const line of lines) {
                            if (Math.abs(line.y - y) < yTolerance) {
                                foundLine = line;
                                break;
                            }
                        }
                        
                        if (!foundLine) {
                            // Create new line
                            foundLine = { y: y, items: [] };
                            lines.push(foundLine);
                        }
                        
                        foundLine.items.push({
                            text: item.str,
                            x: x,
                            width: item.width,
                            height: item.height,
                            isRTL: isRTLItem,
                            transform: transform
                        });
                    }
                    
                    // Sort lines by Y position (top to bottom)
                    lines.sort((a, b) => b.y - a.y);
                    
                    // Process each line: sort items by X position, then merge into paragraphs
                    let pageText = '';
                    let lastLineEndX = null;
                    let lastLineY = null;
                    let currentParagraph = '';
                    
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        
                        // Check if this line contains RTL/Arabic text
                        const hasRTL = line.items.some(item => item.isRTL || /[\u0600-\u06FF]/.test(item.text));
                        
                        // For RTL text, we need to be more careful about ordering
                        if (hasRTL) {
                            // Try sorting right-to-left first (standard RTL reading order)
                            // Sort by right edge position (x + width) descending
                            line.items.sort((a, b) => (b.x + b.width) - (a.x + a.width));
                            
                            // Build a test string to check readability
                            const testText = line.items.map(item => item.text).join('');
                            const arabicChars = (testText.match(/[\u0600-\u06FF]/g) || []).length;
                            
                            // If we have Arabic text, check if reversing the sort order helps
                            // Sometimes PDF.js stores RTL text items in visual order (LTR)
                            if (arabicChars > 0 && line.items.length > 1) {
                                // Try the opposite order
                                const reversedItems = [...line.items].reverse();
                                const reversedTestText = reversedItems.map(item => item.text).join('');
                                
                                // Heuristic: Arabic text often starts with certain characters or patterns
                                // If reversed order starts with more common Arabic start characters, use that
                                const commonArabicStarts = /^[\u0627\u0628\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063A\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u064A]/;
                                const originalStarts = commonArabicStarts.test(testText.trim());
                                const reversedStarts = commonArabicStarts.test(reversedTestText.trim());
                                
                                // If reversed order starts better with Arabic, use reversed order
                                if (reversedStarts && !originalStarts) {
                                    line.items = reversedItems;
                                }
                            }
                        } else {
                            // For LTR text, sort left-to-right (by X position ascending)
                            line.items.sort((a, b) => a.x - b.x);
                        }
                        
                        // Build the text for this line
                        let lineText = '';
                        const textParts = [];
                        
                        for (let j = 0; j < line.items.length; j++) {
                            const item = line.items[j];
                            textParts.push({
                                text: item.text,
                                x: item.x,
                                width: item.width,
                                isRTL: item.isRTL
                            });
                        }
                        
                        // For RTL lines, we might need to reverse the entire concatenation
                        // Build text carefully, considering spacing
                        for (let j = 0; j < textParts.length; j++) {
                            const part = textParts[j];
                            lineText += part.text;
                            
                            // Add space if items are far apart (likely separate words)
                            if (j < textParts.length - 1) {
                                const nextPart = textParts[j + 1];
                                if (hasRTL) {
                                    // For RTL, check spacing based on sort order
                                    // If sorted right-to-left, nextPart is to the left
                                    let spacing;
                                    if (part.x > nextPart.x) {
                                        // Current is to the right, next is to the left (normal RTL)
                                        spacing = part.x - (nextPart.x + nextPart.width);
                                    } else {
                                        // Items might be in visual order, check differently
                                        spacing = Math.abs(part.x - (nextPart.x + nextPart.width));
                                    }
                                    if (spacing > Math.max(part.width, nextPart.width) * 0.2) {
                                        lineText += ' ';
                                    }
                                } else {
                                    // For LTR, normal spacing check
                                    const spacing = nextPart.x - (part.x + part.width);
                                    if (spacing > part.width * 0.3) {
                                        lineText += ' ';
                                    }
                                }
                            }
                        }
                        
                        lineText = lineText.trim();
                        if (!lineText) continue;
                        
                        // For RTL text, the items are now sorted in reading order
                        // The concatenated string should be correct, but sometimes PDF.js extracts
                        // individual characters in reverse order within items
                        // Only reverse if the text clearly looks backwards (starts with punctuation, ends with letter)
                        if (hasRTL && lineText.length > 1) {
                            const arabicRatio = (lineText.match(/[\u0600-\u06FF]/g) || []).length / lineText.length;
                            if (arabicRatio > 0.3) {
                                // Check if it looks reversed: starts with punctuation/space, ends with Arabic letter
                                const startsWithPunct = /^[\s\.,;:!?\-\(\)]/.test(lineText);
                                const endsWithArabic = /[\u0600-\u06FF]$/.test(lineText);
                                
                                // If it starts with punctuation and ends with Arabic, it might be reversed
                                if (startsWithPunct && endsWithArabic) {
                                    lineText = lineText.split('').reverse().join('');
                                }
                            }
                        }
                        
                        // Check if current paragraph is RTL
                        const currentIsRTL = currentParagraph && /[\u0600-\u06FF]/.test(currentParagraph);
                        const lineIsRTL = hasRTL;
                        
                        // Don't merge RTL and LTR text into the same paragraph
                        if (currentParagraph && currentIsRTL !== lineIsRTL) {
                            // Save current paragraph before switching direction
                            pageText += currentParagraph.trim() + '\n';
                            currentParagraph = lineText + ' ';
                        } else {
                            // Determine if this is a new paragraph or continuation
                            const isNewParagraph = this.isNewParagraph(
                                lineText, 
                                currentParagraph, 
                                lastLineEndX, 
                                hasRTL ? line.items[line.items.length - 1].x : line.items[0].x,
                                lastLineY,
                                line.y,
                                hasRTL
                            );
                            
                            if (isNewParagraph && currentParagraph) {
                                // Save current paragraph
                                pageText += currentParagraph.trim() + '\n';
                                currentParagraph = lineText + ' ';
                            } else {
                                // Continue current paragraph
                                // For both RTL and LTR, append normally - the browser will handle RTL display
                                // The items are already sorted in the correct reading order
                                if (currentParagraph && !currentParagraph.endsWith(' ')) {
                                    currentParagraph += ' ';
                                }
                                currentParagraph += lineText + ' ';
                            }
                        }
                        
                        // Track line end position (for RTL, track start; for LTR, track end)
                        if (hasRTL) {
                            const firstItem = line.items[0];
                            lastLineEndX = firstItem.x;
                        } else {
                            const lastItem = line.items[line.items.length - 1];
                            lastLineEndX = lastItem.x + lastItem.width;
                        }
                        lastLineY = line.y;
                    }
                    
                    // Add final paragraph
                    if (currentParagraph) {
                        pageText += currentParagraph.trim() + '\n';
                    }
                    
                    fullText += pageText + '\n';
                }
                
                // Clean up the text: remove excessive whitespace but preserve paragraph breaks
                fullText = fullText.replace(/\n{3,}/g, '\n\n');
                
                // Parse the extracted text
                const blocks = this.parseScreenplayText(fullText);
                this.state = blocks;
                this.save();
                this.render();
            } catch (error) {
                throw new Error('Failed to parse PDF: ' + error.message);
            }
        }
        
        // Helper method to determine if a line starts a new paragraph
        isNewParagraph(lineText, currentParagraph, lastLineEndX, currentLineStartX, lastLineY, currentLineY, isRTL = false) {
            // If no current paragraph, this is definitely new
            if (!currentParagraph) return true;
            
            // Scene headings, transitions, character names always start new paragraphs
            if (/^(INT\.|EXT\.|EST\.|I\/E|INTERIOR|EXTERIOR)/i.test(lineText) ||
                /^(FADE|CUT|DISSOLVE|SMASH|WIPE|IRIS|MATCH)\s+(TO|IN|OUT|BLACK)/i.test(lineText) ||
                /^(FADE|CUT|DISSOLVE|SMASH|WIPE|IRIS|MATCH):$/i.test(lineText)) {
                return true;
            }
            
            // Character names (short, all caps, no punctuation)
            if (lineText.length < 50 && 
                lineText === lineText.toUpperCase() && 
                !lineText.includes('.') && 
                !lineText.includes(',') &&
                !/^(INT|EXT|EST|I\/E)/i.test(lineText)) {
                return true;
            }
            
            // Large Y gap indicates new paragraph (more than ~1.5x line height)
            if (lastLineY !== null && currentLineY !== null) {
                const lineHeight = Math.abs(currentLineY - lastLineY);
                const avgLineHeight = 12; // Approximate line height in PDF units
                if (lineHeight > avgLineHeight * 1.5) {
                    return true;
                }
            }
            
            // For RTL text, check positioning differently
            if (isRTL) {
                // For RTL, if line starts significantly to the right of where last line ended, might be new paragraph
                if (lastLineEndX !== null && currentLineStartX !== null) {
                    const significantGap = 20; // Significant rightward movement for RTL
                    // In RTL, text flows right-to-left, so if current line is significantly to the right, it's likely new
                    if (currentLineStartX > (lastLineEndX + significantGap)) {
                        // Check if previous paragraph ended with sentence-ending punctuation
                        if (currentParagraph && /[.!?]\s*$/.test(currentParagraph.trim())) {
                            return true;
                        }
                    }
                }
            } else {
                // For LTR text, original logic
                // If line starts far to the left (indented), might be new paragraph
                if (lastLineEndX !== null && currentLineStartX !== null) {
                    const leftMargin = 72; // Typical left margin
                    const significantIndent = 20; // Significant leftward movement
                    
                    // If current line starts significantly to the left of where last line ended
                    if (currentLineStartX < (lastLineEndX - significantIndent)) {
                        // Check if previous paragraph ended with sentence-ending punctuation
                        if (currentParagraph && /[.!?]\s*$/.test(currentParagraph.trim())) {
                            return true;
                        }
                    }
                }
            }
            
            // If line starts with capital after sentence-ending punctuation in previous
            // (This works for both LTR and RTL, as Arabic punctuation is different)
            if (currentParagraph && /[.!?]\s*$/.test(currentParagraph.trim())) {
                // For Arabic/RTL, check for Arabic sentence endings or new Arabic sentence start
                if (isRTL && /[\u0600-\u06FF]/.test(lineText)) {
                    // Arabic text after punctuation - likely new sentence, but might be same paragraph
                    // Don't break on every sentence in Arabic dialogue
                    return false;
                } else if (!isRTL && /^[A-Z]/.test(lineText)) {
                    // But don't break if it's clearly a continuation (lowercase, or mid-sentence)
                    if (!/^[a-z]/.test(lineText) && lineText.length > 3) {
                        // Could be new sentence or new paragraph - check context
                        // If previous was very short, likely continuation
                        if (currentParagraph.trim().length < 20) {
                            return false;
                        }
                        return true;
                    }
                }
            }
            
            return false;
        }

        // Load DOCX file
        async loadDOCX(file) {
            try {
                if (typeof JSZip === 'undefined') {
                    throw new Error('JSZip library not loaded. Please refresh the page.');
                }
                
                const arrayBuffer = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(arrayBuffer);
                
                // DOCX files contain document.xml in word/document.xml
                const docFile = zip.file('word/document.xml');
                if (!docFile) {
                    throw new Error('Invalid DOCX file: document.xml not found');
                }
                
                const docXml = await docFile.async('string');
                
                // Parse XML to extract text
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(docXml, 'text/xml');
                
                // Check for parsing errors
                const parserError = xmlDoc.querySelector('parsererror');
                if (parserError) {
                    throw new Error('Failed to parse DOCX XML structure');
                }
                
                // Extract all text nodes, preserving paragraph breaks
                const paragraphs = xmlDoc.getElementsByTagName('w:p');
                let fullText = '';
                
                for (let i = 0; i < paragraphs.length; i++) {
                    const paragraph = paragraphs[i];
                    const textNodes = paragraph.getElementsByTagName('w:t');
                    let paraText = '';
                    
                    // Collect all text from this paragraph
                    for (let j = 0; j < textNodes.length; j++) {
                        const textNode = textNodes[j];
                        paraText += textNode.textContent || '';
                    }
                    
                    // Also check for line breaks within paragraph (w:br)
                    const breaks = paragraph.getElementsByTagName('w:br');
                    if (breaks.length > 0 && paraText) {
                        // If there are breaks, we might need to split
                        paraText = paraText.trim();
                    }
                    
                    if (paraText.trim()) {
                        fullText += paraText.trim() + '\n';
                    }
                }
                
                if (!fullText || fullText.trim().length < 10) {
                    throw new Error('No text content found in DOCX file');
                }
                
                // Parse the extracted text
                const blocks = this.parseScreenplayText(fullText);
                this.state = blocks;
                this.save();
                this.render();
            } catch (error) {
                throw new Error('Failed to parse DOCX: ' + error.message);
            }
        }

        // Load Pages file
        async loadPages(file) {
            try {
                if (typeof JSZip === 'undefined') {
                    throw new Error('JSZip library not loaded. Please refresh the page.');
                }
                
                const arrayBuffer = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(arrayBuffer);
                
                // Pages files are zip archives with various structures
                const fileNames = Object.keys(zip.files);
                let fullText = '';
                
                // Strategy 1: Look for preview.pdf (most reliable)
                let previewPdf = null;
                for (const fileName of fileNames) {
                    if (fileName.includes('preview.pdf') || fileName.endsWith('preview.pdf')) {
                        previewPdf = fileName;
                        break;
                    }
                }
                
                if (previewPdf) {
                    try {
                        const pdfBlob = await zip.file(previewPdf).async('blob');
                        const pdfFile = new File([pdfBlob], 'preview.pdf', { type: 'application/pdf' });
                        await this.loadPDF(pdfFile);
                        return;
                    } catch (e) {
                        console.warn('Failed to parse preview.pdf, trying other methods:', e);
                    }
                }
                
                // Strategy 2: Look for index.xml.zip (nested zip)
                let indexXmlZip = null;
                for (const fileName of fileNames) {
                    if (fileName.includes('index.xml.zip') || fileName.endsWith('index.xml.zip')) {
                        indexXmlZip = fileName;
                        break;
                    }
                }
                
                if (indexXmlZip) {
                    try {
                        const nestedZipBlob = await zip.file(indexXmlZip).async('blob');
                        const nestedZip = await JSZip.loadAsync(nestedZipBlob);
                        const nestedFiles = Object.keys(nestedZip.files);
                        
                        // Look for index.xml or index.apxl inside the nested zip
                        for (const nestedFile of nestedFiles) {
                            if (nestedFile.includes('index.xml') || nestedFile.includes('index.apxl')) {
                                const xmlContent = await nestedZip.file(nestedFile).async('string');
                                fullText = this.extractTextFromPagesXML(xmlContent);
                                if (fullText && fullText.trim().length > 10) break;
                            }
                        }
                    } catch (e) {
                        console.warn('Failed to parse index.xml.zip:', e);
                    }
                }
                
                // Strategy 3: Look for index.xml directly
                if (!fullText || fullText.trim().length < 10) {
                    for (const fileName of fileNames) {
                        if (fileName.includes('index.xml') && !fileName.includes('.zip')) {
                            try {
                                const xmlContent = await zip.file(fileName).async('string');
                                fullText = this.extractTextFromPagesXML(xmlContent);
                                if (fullText && fullText.trim().length > 10) break;
                            } catch (e) {
                                console.warn('Failed to parse', fileName, e);
                            }
                        }
                    }
                }
                
                // Strategy 4: Look for .apxl files (Pages XML format)
                if (!fullText || fullText.trim().length < 10) {
                    for (const fileName of fileNames) {
                        if (fileName.endsWith('.apxl') || fileName.includes('.apxl/')) {
                            try {
                                const xmlContent = await zip.file(fileName).async('string');
                                fullText = this.extractTextFromPagesXML(xmlContent);
                                if (fullText && fullText.trim().length > 10) break;
                            } catch (e) {
                                // Skip binary or non-text files
                            }
                        }
                    }
                }
                
                // Strategy 5: Try all XML files (last resort)
                if (!fullText || fullText.trim().length < 10) {
                    for (const fileName of fileNames) {
                        if (fileName.endsWith('.xml') && 
                            !fileName.includes('Metadata') && 
                            !fileName.includes('Info.plist') &&
                            !fileName.includes('Settings')) {
                            try {
                                const xmlContent = await zip.file(fileName).async('string');
                                const extracted = this.extractTextFromPagesXML(xmlContent);
                                if (extracted && extracted.trim().length > 50) {
                                    fullText += extracted + '\n';
                                }
                            } catch (e) {
                                // Skip files that can't be parsed
                            }
                        }
                    }
                }
                
                if (!fullText || fullText.trim().length < 10) {
                    throw new Error('Could not extract text from Pages file. The file may be corrupted or in an unsupported format. Try exporting to PDF or DOCX first.');
                }
                
                // Clean up the text
                fullText = fullText.replace(/\n{3,}/g, '\n\n').trim();
                
                // Parse the extracted text
                const blocks = this.parseScreenplayText(fullText);
                this.state = blocks;
                this.save();
                this.render();
            } catch (error) {
                throw new Error('Failed to parse Pages file: ' + error.message);
            }
        }
        
        // Helper method to extract text from Pages XML
        extractTextFromPagesXML(xmlContent) {
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
                
                // Check for parsing errors
                const parserError = xmlDoc.querySelector('parsererror');
                if (parserError) {
                    return null;
                }
                
                let fullText = '';
                
                // Try multiple extraction strategies for Pages XML
                
                // Strategy 1: Look for <text> elements
                const textNodes = xmlDoc.getElementsByTagName('text');
                if (textNodes.length > 0) {
                    for (let i = 0; i < textNodes.length; i++) {
                        const text = textNodes[i].textContent || textNodes[i].innerText || '';
                        if (text.trim()) {
                            fullText += text.trim() + '\n';
                        }
                    }
                }
                
                // Strategy 2: Look for <p> (paragraph) elements
                if (!fullText || fullText.trim().length < 10) {
                    const paragraphs = xmlDoc.getElementsByTagName('p');
                    if (paragraphs.length > 0) {
                        for (let i = 0; i < paragraphs.length; i++) {
                            const text = paragraphs[i].textContent || paragraphs[i].innerText || '';
                            if (text.trim()) {
                                fullText += text.trim() + '\n';
                            }
                        }
                    }
                }
                
                // Strategy 3: Look for any element with text content
                if (!fullText || fullText.trim().length < 10) {
                    // Get all elements and extract text
                    const allElements = xmlDoc.getElementsByTagName('*');
                    for (let i = 0; i < allElements.length; i++) {
                        const elem = allElements[i];
                        // Skip if it has child elements (we want leaf nodes)
                        if (elem.children.length === 0) {
                            const text = elem.textContent || elem.innerText || '';
                            if (text.trim() && text.trim().length > 1) {
                                fullText += text.trim() + ' ';
                            }
                        }
                    }
                }
                
                // Strategy 4: Last resort - get all text content
                if (!fullText || fullText.trim().length < 10) {
                    const allText = xmlDoc.textContent || xmlDoc.documentElement?.textContent || '';
                    if (allText && allText.trim().length > 10) {
                        fullText = allText;
                    }
                }
                
                return fullText.trim();
            } catch (e) {
                console.warn('Error extracting text from Pages XML:', e);
                return null;
            }
        }

        exportPDF() {
            // Use browser's native print functionality with CSS print styles
            // This creates proper PDFs with selectable text and correct pagination
            
            const pageElement = document.getElementById('page');
            if (!pageElement) {
                alert('No content to export.');
                return;
            }

            // Get the title from title page for filename
            let pdfTitle = 'Last Draft';
            if (this.titlePage && this.titlePage.title && this.titlePage.title.trim()) {
                pdfTitle = this.titlePage.title.trim();
                // Clean the title for use as filename (remove quotes, special chars)
                pdfTitle = pdfTitle.replace(/^["']|["']$/g, '').trim();
                // Replace invalid filename characters
                pdfTitle = pdfTitle.replace(/[<>:"/\\|?*]/g, '');
                // Limit length
                if (pdfTitle.length > 100) {
                    pdfTitle = pdfTitle.substring(0, 100);
                }
            }

            // Temporarily change document title so browsers use it as suggested filename
            const originalTitle = document.title;
            document.title = pdfTitle;

            // Render title page if it has content
            const titlePagePrint = document.getElementById('title-page-print');
            if (titlePagePrint) {
                const hasTitlePage = this.titlePage && (
                    this.titlePage.title || 
                    this.titlePage.writer || 
                    (this.titlePage.customAreas && this.titlePage.customAreas.length > 0)
                );
                
                if (hasTitlePage) {
                    let customAreasHtml = '';
                    if (this.titlePage.customAreas && this.titlePage.customAreas.length > 0) {
                        customAreasHtml = this.titlePage.customAreas.map(area => 
                            `<div class="title-page-custom">${this.escapeHtml(area)}</div>`
                        ).join('');
                    }
                    
                    titlePagePrint.innerHTML = `
                        <div class="title-page-content-wrapper">
                            ${this.titlePage.title ? `<div class="title-page-title">"${this.escapeHtml(this.titlePage.title)}"</div>` : ''}
                            ${this.titlePage.writer ? `<div class="title-page-written-by">Written by</div><div class="title-page-writer">${this.escapeHtml(this.titlePage.writer)}</div>` : ''}
                            ${customAreasHtml}
                        </div>
                    `;
                    titlePagePrint.style.display = 'block';
                } else {
                    titlePagePrint.style.display = 'none';
                }
            }

            // Ensure all replicators are visible for print with markdown formatting
            const replicators = pageElement.querySelectorAll('.replicator');
            replicators.forEach(replicator => {
                // Replicators are already set up in CSS for print
                // Just ensure they're ready with markdown formatting
                const textarea = replicator.parentElement.querySelector('textarea');
                if (textarea) {
                    const text = textarea.value;
                    if (text.trim().length > 0) {
                        replicator.innerHTML = this.parseMarkdown(text);
                    }
                }
            });

            // Trigger browser's print dialog
            // The @media print CSS will handle all styling, margins, and pagination
            // The document title will be used as the suggested filename
            window.print();
            
            // Restore original title after a short delay (print dialog is async)
            setTimeout(() => {
                document.title = originalTitle;
            }, 1000);
            
            // Hide title page after printing
            if (titlePagePrint) {
                titlePagePrint.style.display = 'none';
            }
        }

        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        initTheme() {
            const savedTheme = localStorage.getItem('nvlastdraft_theme') || 'dark';
            if (savedTheme === 'light') {
                document.body.classList.add('light-mode');
            }
            this.updateThemeIcon();
        }

        toggleTheme() {
            document.body.classList.toggle('light-mode');
            const isLight = document.body.classList.contains('light-mode');
            localStorage.setItem('nvlastdraft_theme', isLight ? 'light' : 'dark');
            this.updateThemeIcon();
        }

        updateThemeIcon() {
            const toggleBtn = document.getElementById('theme-toggle');
            if (toggleBtn) {
                const isLight = document.body.classList.contains('light-mode');
                toggleBtn.textContent = isLight ? '' : '';
                toggleBtn.title = isLight ? 'Switch to Dark Mode' : 'Switch to Light Mode';
            }
        }

        // --- SCENE MAP ---

        buildSceneMap() {
            this.scenes = [];
            const sceneRows = this.page.querySelectorAll('.row.scene');
            sceneRows.forEach((row, index) => {
                const id = row.id;
                const textarea = row.querySelector('textarea');
                const label = textarea ? textarea.value.trim() : '';
                // Extract state index from row ID (row-X format)
                const stateIndex = id.startsWith('row-') ? parseInt(id.replace('row-', '')) : null;
                if (id && stateIndex !== null) {
                    // Collect all content from this scene until the next scene
                    let sceneContent = label;
                    let currentRow = row.nextElementSibling;
                    while (currentRow) {
                        if (currentRow.classList.contains('scene')) {
                            break; // Next scene found
                        }
                        const rowTextarea = currentRow.querySelector('textarea');
                        if (rowTextarea) {
                            sceneContent += ' ' + rowTextarea.value;
                        }
                        currentRow = currentRow.nextElementSibling;
                    }
                    
                    this.scenes.push({
                        id: id,
                        stateIndex: stateIndex,
                        index: index + 1,
                        label: label,
                        content: sceneContent.toLowerCase()
                    });
                }
            });
            this.renderSceneMap();
        }

        renderSceneMap(filterText = '') {
            const sceneList = document.getElementById('scene-list');
            if (!sceneList) return;

            // Update header with scene count
            const sceneMapHeader = document.querySelector('.scene-map-header');
            if (sceneMapHeader) {
                const sceneCount = this.scenes.length;
                if (sceneCount === 1) {
                    sceneMapHeader.textContent = '1 SCENE';
                } else if (sceneCount > 1) {
                    sceneMapHeader.textContent = `${sceneCount} SCENES`;
                } else {
                    sceneMapHeader.textContent = 'SCENES';
                }
            }

            sceneList.innerHTML = '';

            const filter = filterText.toLowerCase().trim();
            const filtered = filter 
                ? this.scenes.filter(s => s.content && s.content.includes(filter))
                : this.scenes;

            // Clear previous highlights
            this.clearSearchHighlights();

            // Apply highlights if there's a search term
            if (filter) {
                this.highlightSearchTerm(filter);
            }

            filtered.forEach(scene => {
                const item = document.createElement('div');
                item.className = 'scene-item';
                item.dataset.sceneId = scene.id;
                item.dataset.stateIndex = scene.stateIndex;
                
                const dragHandle = document.createElement('div');
                dragHandle.className = 'scene-drag-handle';
                dragHandle.textContent = '';
                dragHandle.draggable = true;
                dragHandle.contentEditable = false;
                
                // Store scene data directly on the element
                dragHandle.dataset.sceneStateIndex = scene.stateIndex.toString();
                dragHandle.dataset.sceneId = scene.id;
                
                // Test mousedown
                dragHandle.addEventListener('mousedown', (e) => {
                    console.log('MOUSEDOWN on drag handle');
                }, false);
                
                // Drag start handler
                dragHandle.addEventListener('dragstart', (e) => {
                    console.log('DRAG START FIRED for scene:', scene.stateIndex);
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', scene.stateIndex.toString());
                    e.dataTransfer.setData('scene-index', scene.stateIndex.toString());
                    item.classList.add('dragging');
                    this.draggedSceneIndex = scene.stateIndex;
                    this.draggedSceneId = scene.id;
                }, false);
                
                // Drag end handler
                dragHandle.addEventListener('dragend', (e) => {
                    console.log('DRAG END FIRED');
                    item.classList.remove('dragging');
                    // Hide drop indicator
                    const dropIndicator = document.getElementById('drop-indicator');
                    if (dropIndicator) {
                        dropIndicator.classList.remove('visible');
                        dropIndicator.style.display = 'none';
                    }
                    // Don't clear draggedSceneIndex immediately - let drop handler do it
                    // Only clear if drop didn't happen (after a delay)
                    setTimeout(() => {
                        if (this.draggedSceneIndex === scene.stateIndex) {
                            console.log('Drag ended without drop, clearing');
                            this.draggedSceneIndex = undefined;
                        }
                    }, 200);
                }, false);
                
                // Prevent click from jumping to scene
                dragHandle.addEventListener('click', (e) => {
                    e.stopPropagation();
                }, false);
                
                const content = document.createElement('span');
                content.className = 'scene-item-content';
                const label = scene.label ? scene.label.toUpperCase() : '(UNTITLED SCENE)';
                
                // Highlight search term in label if it matches
                if (filter && scene.content && scene.content.includes(filter)) {
                    item.classList.add('match');
                    // Highlight matching words in the label
                    const highlightedLabel = this.highlightText(label, filter);
                    content.innerHTML = `${scene.index}. ${highlightedLabel}`;
                } else {
                    content.textContent = `${scene.index}. ${label}`;
                }
                
                content.addEventListener('click', () => this.jumpToScene(scene.id), false);
                content.style.userSelect = 'none';
                
                item.appendChild(dragHandle);
                item.appendChild(content);
                sceneList.appendChild(item);
            });
        }

        highlightText(text, searchTerm) {
            if (!searchTerm) return text;
            const regex = new RegExp(`(${this.escapeRegex(searchTerm)})`, 'gi');
            return text.replace(regex, '<span class="search-highlight">$1</span>');
        }

        escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        highlightSearchTerm(searchTerm) {
            if (!searchTerm) return;
            
            const searchRegex = new RegExp(`(${this.escapeRegex(searchTerm)})`, 'gi');
            const allTextareas = this.page.querySelectorAll('textarea');
            
            allTextareas.forEach(textarea => {
                const originalValue = textarea.value;
                // Find the parent row
                const row = textarea.closest('.row');
                if (row) {
                    // Check if this row contains the search term
                    if (searchRegex.test(originalValue)) {
                        row.classList.add('search-match');
                        // Store the original value for when we clear highlights
                        if (!row.dataset.originalValue) {
                            row.dataset.originalValue = originalValue;
                        }
                    } else {
                        row.classList.remove('search-match');
                    }
                }
            });
        }

        clearSearchHighlights() {
            // Clear highlights from rows
            const rows = this.page.querySelectorAll('.row.search-match');
            rows.forEach(row => {
                row.classList.remove('search-match');
            });
            
            // Clear match class from scene items
            const sceneItems = document.querySelectorAll('.scene-item.match');
            sceneItems.forEach(item => item.classList.remove('match'));
        }

        jumpToScene(rowId) {
            const element = document.getElementById(rowId);
            if (!element) return;

            // Scroll into view
            element.scrollIntoView({ behavior: 'smooth', block: 'center' });

            // Add highlight class
            element.classList.add('jump-highlight');
            
            // Remove highlight after animation
            setTimeout(() => {
                element.classList.remove('jump-highlight');
            }, 1000);

            // Update active state in scene list
            const sceneItems = document.querySelectorAll('.scene-item');
            sceneItems.forEach(item => item.classList.remove('active'));
            const clickedScene = this.scenes.find(s => s.id === rowId);
            if (clickedScene) {
                const index = this.scenes.indexOf(clickedScene);
                const filtered = document.getElementById('scene-search').value.toLowerCase().trim();
                const filteredScenes = filtered 
                    ? this.scenes.filter(s => s.label.toLowerCase().includes(filtered))
                    : this.scenes;
                const displayIndex = filteredScenes.findIndex(s => s.id === rowId);
                if (displayIndex >= 0 && sceneItems[displayIndex]) {
                    sceneItems[displayIndex].classList.add('active');
                }
            }
        }

        toggleSceneMap() {
            const sceneMap = document.getElementById('scene-map');
            if (sceneMap) {
                const wasClosed = !sceneMap.classList.contains('open');
                sceneMap.classList.toggle('open');
                // Rebuild scene map when opening if needed
                if (wasClosed && this.sceneMapNeedsRebuild) {
                    this.buildSceneMap();
                    this.sceneMapNeedsRebuild = false;
                }
            }
        }

        // --- TITLE PAGE ---

        openTitlePage() {
            const modal = document.getElementById('title-page-modal');
            if (modal) {
                // Populate fields with current data
                document.getElementById('title-page-title').value = this.titlePage.title || '';
                document.getElementById('title-page-writer').value = this.titlePage.writer || '';
                
                // Render custom areas
                this.renderCustomAreas();
                
                modal.classList.add('open');
            }
        }

        closeTitlePage() {
            const modal = document.getElementById('title-page-modal');
            if (modal) {
                modal.classList.remove('open');
            }
        }

        renderCustomAreas() {
            const customList = document.getElementById('title-page-custom-list');
            if (!customList) return;
            
            customList.innerHTML = '';
            const customAreas = this.titlePage.customAreas || [];
            
            if (customAreas.length === 0) {
                // Add one empty custom area by default
                this.addCustomArea();
            } else {
                customAreas.forEach((area, index) => {
                    this.addCustomArea(area, index);
                });
            }
        }

        addCustomArea(text = '', index = null) {
            const customList = document.getElementById('title-page-custom-list');
            if (!customList) return;
            
            const item = document.createElement('div');
            item.className = 'title-page-custom-item';
            const itemIndex = index !== null ? index : (this.titlePage.customAreas || []).length;
            
            item.innerHTML = `
                <textarea class="custom-area-text" data-index="${itemIndex}" placeholder="Add any detail, note, contact, copyright, etc.">${this.escapeHtml(text)}</textarea>
                <button type="button" class="remove-custom-area" onclick="app.removeCustomArea(${itemIndex})" title="Remove"></button>
            `;
            
            if (index !== null) {
                const existingItems = customList.querySelectorAll('.title-page-custom-item');
                if (existingItems[index]) {
                    customList.insertBefore(item, existingItems[index]);
                } else {
                    customList.appendChild(item);
                }
            } else {
                customList.appendChild(item);
            }
            
            // Update data indices
            this.updateCustomAreaIndices();
        }

        removeCustomArea(index) {
            if (!this.titlePage.customAreas) return;
            this.titlePage.customAreas.splice(index, 1);
            this.renderCustomAreas();
        }

        updateCustomAreaIndices() {
            const items = document.querySelectorAll('.title-page-custom-item');
            items.forEach((item, index) => {
                const textarea = item.querySelector('textarea');
                const button = item.querySelector('.remove-custom-area');
                if (textarea) textarea.setAttribute('data-index', index);
                if (button) {
                    button.setAttribute('onclick', `app.removeCustomArea(${index})`);
                }
            });
        }

        saveTitlePage() {
            const title = document.getElementById('title-page-title').value.trim();
            const writer = document.getElementById('title-page-writer').value.trim();
            
            // Collect custom areas
            const customAreas = [];
            const customTextareas = document.querySelectorAll('.custom-area-text');
            customTextareas.forEach(textarea => {
                const text = textarea.value.trim();
                if (text) {
                    customAreas.push(text);
                }
            });
            
            this.titlePage = {
                title: title,
                writer: writer,
                customAreas: customAreas
            };
            this.save();
            this.closeTitlePage();
        }


        initDragDrop() {
            const workspace = document.getElementById('workspace');
            const page = document.getElementById('page');

            // Create drop indicator element
            const dropIndicator = document.createElement('div');
            dropIndicator.className = 'drop-indicator';
            dropIndicator.id = 'drop-indicator';
            dropIndicator.style.display = 'block';
            document.body.appendChild(dropIndicator);
            console.log('Drop indicator created');

            // Handle drag enter and over on both workspace and page
            const handleDragOver = (e) => {
                // Always prevent default to allow drop - check for our drag type
                const types = Array.from(e.dataTransfer.types || []);
                const hasTextPlain = types.includes('text/plain');
                const hasSceneIndex = types.includes('scene-index');
                
                if (this.draggedSceneIndex !== undefined || hasTextPlain || hasSceneIndex) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.dataTransfer.dropEffect = 'move';
                    this.page.classList.add('drag-over');
                    
                    // Find the row under the cursor and determine drop position
                    const rows = Array.from(this.page.querySelectorAll('.row'));
                    let dropY = e.clientY;
                    let insertBefore = true;

                    // Find closest row
                    let closestRow = null;
                    let closestDistance = Infinity;
                    for (const row of rows) {
                        const rect = row.getBoundingClientRect();
                        const distance = Math.abs(e.clientY - (rect.top + rect.height / 2));
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestRow = row;
                        }
                    }

                    if (closestRow) {
                        const rect = closestRow.getBoundingClientRect();
                        const midPoint = rect.top + rect.height / 2;
                        
                        // Determine if we should insert before or after
                        if (e.clientY < midPoint) {
                            insertBefore = true;
                            dropY = rect.top;
                        } else {
                            insertBefore = false;
                            dropY = rect.bottom;
                        }
                    } else {
                        // No rows found, use cursor Y position
                        dropY = e.clientY;
                    }

                    // Update drop indicator position (fixed positioning relative to viewport)
                    const pageRect = this.page.getBoundingClientRect();
                    dropIndicator.style.top = dropY + 'px';
                    dropIndicator.style.left = pageRect.left + 'px';
                    dropIndicator.style.width = pageRect.width + 'px';
                    dropIndicator.style.display = 'block';
                    dropIndicator.style.opacity = '1';
                    dropIndicator.classList.add('visible');

                    // Clear previous targets
                    document.querySelectorAll('.row.drag-target').forEach(r => {
                        r.classList.remove('drag-target');
                    });
                }
            };

            // Handle dragenter - must prevent default to allow drop
            workspace.addEventListener('dragenter', (e) => {
                const types = Array.from(e.dataTransfer.types || []);
                const hasTextPlain = types.includes('text/plain');
                console.log('DRAGENTER on workspace - types:', types, 'draggedSceneIndex:', this.draggedSceneIndex);
                if (this.draggedSceneIndex !== undefined || hasTextPlain) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.page.classList.add('drag-over');
                }
            }, false);

            page.addEventListener('dragenter', (e) => {
                const types = Array.from(e.dataTransfer.types || []);
                const hasTextPlain = types.includes('text/plain');
                console.log('DRAGENTER on page - types:', types, 'draggedSceneIndex:', this.draggedSceneIndex);
                if (this.draggedSceneIndex !== undefined || hasTextPlain) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.page.classList.add('drag-over');
                }
            }, false);

            workspace.addEventListener('dragover', handleDragOver, false);
            page.addEventListener('dragover', handleDragOver, false);
            
            // Also add to document body as fallback - but use capture phase so workspace handlers can also fire
            document.body.addEventListener('dragover', (e) => {
                const types = Array.from(e.dataTransfer.types || []);
                if (types.includes('text/plain')) {
                    console.log('DRAGOVER on body - allowing');
                    e.preventDefault();
                    // Don't stop propagation - let workspace handlers also fire
                    e.dataTransfer.dropEffect = 'move';
                    
                    // Check if we're over the scene map
                    const sceneMap = document.getElementById('scene-map');
                    const sceneList = document.getElementById('scene-list');
                    
                    if (sceneMap && sceneList && sceneMap.contains(e.target)) {
                        // We're dragging over the scene map - show indicator in scene map
                        const sceneItems = Array.from(sceneList.querySelectorAll('.scene-item'));
                        let dropY = e.clientY;
                        let closestItem = null;
                        let closestDistance = Infinity;
                        let insertBefore = true;
                        
                        // Find closest scene item
                        for (const item of sceneItems) {
                            const rect = item.getBoundingClientRect();
                            const distance = Math.abs(e.clientY - (rect.top + rect.height / 2));
                            if (distance < closestDistance) {
                                closestDistance = distance;
                                closestItem = item;
                            }
                        }
                        
                        if (closestItem) {
                            const rect = closestItem.getBoundingClientRect();
                            const midPoint = rect.top + rect.height / 2;
                            if (e.clientY < midPoint) {
                                insertBefore = true;
                                dropY = rect.top;
                            } else {
                                insertBefore = false;
                                dropY = rect.bottom;
                            }
                        }
                        
                        // Update drop indicator in scene map
                        const sceneMapRect = sceneMap.getBoundingClientRect();
                        dropIndicator.style.top = dropY + 'px';
                        dropIndicator.style.left = sceneMapRect.left + 'px';
                        dropIndicator.style.width = sceneMapRect.width + 'px';
                        dropIndicator.style.display = 'block';
                        dropIndicator.style.opacity = '1';
                        dropIndicator.classList.add('visible');
                        console.log('Drop indicator updated in scene map: top=', dropY);
                    } else {
                        // We're dragging over the workspace - show indicator in workspace
                        // Find all scene rows to snap between them
                        const sceneRows = Array.from(this.page.querySelectorAll('.row.scene'));
                        let dropY = e.clientY;
                        let snapY = null;
                        let snapDistance = Infinity;
                        
                        // Find the closest snap point (between scenes or before/after scenes)
                        for (let i = 0; i < sceneRows.length; i++) {
                            const sceneRow = sceneRows[i];
                            const rect = sceneRow.getBoundingClientRect();
                            
                            // Check top edge (before this scene)
                            const topDistance = Math.abs(e.clientY - rect.top);
                            if (topDistance < snapDistance) {
                                snapDistance = topDistance;
                                snapY = rect.top;
                            }
                            
                            // Check bottom edge (after this scene)
                            const bottomDistance = Math.abs(e.clientY - rect.bottom);
                            if (bottomDistance < snapDistance) {
                                snapDistance = bottomDistance;
                                snapY = rect.bottom;
                            }
                            
                            // Also check between this scene and next scene
                            if (i < sceneRows.length - 1) {
                                const nextRect = sceneRows[i + 1].getBoundingClientRect();
                                const betweenY = (rect.bottom + nextRect.top) / 2;
                                const betweenDistance = Math.abs(e.clientY - betweenY);
                                if (betweenDistance < snapDistance) {
                                    snapDistance = betweenDistance;
                                    snapY = betweenY;
                                }
                            }
                        }
                        
                        // If we found a snap point within reasonable distance, use it
                        if (snapY !== null && snapDistance < 50) {
                            dropY = snapY;
                        } else {
                            // Otherwise, find closest regular row
                            const rows = Array.from(this.page.querySelectorAll('.row'));
                            let closestRow = null;
                            let closestDistance = Infinity;
                            for (const row of rows) {
                                const rect = row.getBoundingClientRect();
                                const distance = Math.abs(e.clientY - (rect.top + rect.height / 2));
                                if (distance < closestDistance) {
                                    closestDistance = distance;
                                    closestRow = row;
                                }
                            }
                            
                            if (closestRow) {
                                const rect = closestRow.getBoundingClientRect();
                                const midPoint = rect.top + rect.height / 2;
                                if (e.clientY < midPoint) {
                                    dropY = rect.top;
                                } else {
                                    dropY = rect.bottom;
                                }
                            }
                        }
                        
                        // Update drop indicator in workspace
                        const pageRect = this.page.getBoundingClientRect();
                        dropIndicator.style.top = dropY + 'px';
                        dropIndicator.style.left = pageRect.left + 'px';
                        dropIndicator.style.width = pageRect.width + 'px';
                        dropIndicator.style.display = 'block';
                        dropIndicator.style.opacity = '1';
                        dropIndicator.classList.add('visible');
                        console.log('Drop indicator updated in workspace: top=', dropY, 'snapped');
                    }
                }
            }, true); // Use capture phase
            
            // Add drop handler to body as well - but don't stop propagation so workspace can handle it
            document.body.addEventListener('drop', (e) => {
                const types = Array.from(e.dataTransfer.types || []);
                if (types.includes('text/plain')) {
                    console.log('DROP on body detected');
                    // Don't prevent default or stop propagation - let workspace handle it
                }
            }, false);
            
            console.log('Drag and drop handlers initialized');

            const handleDrop = (e) => {
                console.log('DROP EVENT FIRED on workspace/page');
                e.preventDefault();
                e.stopPropagation();
                
                // Hide drop indicator
                dropIndicator.classList.remove('visible');
                
                // Get drag data from dataTransfer
                const dragData = e.dataTransfer.getData('text/plain');
                const sceneIndex = dragData ? parseInt(dragData) : this.draggedSceneIndex;
                
                console.log('Drop data:', dragData, 'sceneIndex:', sceneIndex, 'draggedSceneIndex:', this.draggedSceneIndex);
                
                // Use whichever is available
                let finalIndex = null;
                if (sceneIndex !== undefined && !isNaN(sceneIndex)) {
                    finalIndex = sceneIndex;
                } else if (this.draggedSceneIndex !== undefined) {
                    finalIndex = this.draggedSceneIndex;
                }
                
                if (finalIndex === null || finalIndex === undefined) {
                    console.log('No valid drag data, aborting drop');
                    return;
                }
                
                console.log('Drop received for scene index:', finalIndex);
                
                this.page.classList.remove('drag-over');
                document.querySelectorAll('.row.drag-target').forEach(row => {
                    row.classList.remove('drag-target');
                });

                // Find drop target - look for the nearest scene
                const rows = Array.from(this.page.querySelectorAll('.row'));
                let targetIndex = this.state.length; // Default to end

                // Find the row closest to the drop point
                let closestRow = null;
                let closestDistance = Infinity;

                for (const row of rows) {
                    const rect = row.getBoundingClientRect();
                    const distance = Math.abs(e.clientY - (rect.top + rect.height / 2));
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestRow = row;
                    }
                }

                if (closestRow) {
                    const rowId = closestRow.id;
                    if (rowId.startsWith('row-')) {
                        const idx = parseInt(rowId.replace('row-', ''));
                        if (closestRow.classList.contains('scene')) {
                            // Dropping on a scene - insert before it
                            targetIndex = idx;
                        } else {
                            // Dropping on a non-scene - find the next scene after it
                            for (let i = idx + 1; i < this.state.length; i++) {
                                if (!this.state[i].isContainer && this.state[i].type === 'scene') {
                                    targetIndex = i;
                                    break;
                                }
                            }
                            // If no scene found after, find the previous scene
                            if (targetIndex === this.state.length) {
                                for (let i = idx - 1; i >= 0; i--) {
                                    if (!this.state[i].isContainer && this.state[i].type === 'scene') {
                                        targetIndex = i + 1; // Insert after the previous scene
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                // Move the scene
                if (targetIndex !== undefined && finalIndex !== undefined) {
                    console.log('Moving scene from', finalIndex, 'to', targetIndex);
                    this.moveScene(finalIndex, targetIndex);
                }

                this.draggedSceneIndex = undefined;
            };

            workspace.addEventListener('drop', handleDrop, false);
            page.addEventListener('drop', handleDrop, false);
            
            // Also add drop to body in capture phase
            document.body.addEventListener('drop', (e) => {
                const types = Array.from(e.dataTransfer.types || []);
                if (types.includes('text/plain')) {
                    console.log('DROP on body in capture - calling handleDrop');
                    handleDrop(e);
                }
            }, true); // Capture phase

            page.addEventListener('dragleave', (e) => {
                // Only remove drag-over if actually leaving the page
                if (!e.relatedTarget || !page.contains(e.relatedTarget)) {
                    this.page.classList.remove('drag-over');
                    document.querySelectorAll('.row.drag-target').forEach(row => {
                        row.classList.remove('drag-target');
                    });
                }
            });
        }

        moveScene(fromIndex, toIndex) {
            console.log('moveScene called: fromIndex=', fromIndex, 'toIndex=', toIndex, 'state.length=', this.state.length);
            
            if (fromIndex === toIndex) {
                console.log('Same index, no move needed');
                return;
            }
            
            if (fromIndex < 0 || fromIndex >= this.state.length) {
                console.log('Invalid fromIndex');
                return;
            }
            
            this.saveToHistory();
            const sceneBlock = this.state[fromIndex];
            console.log('Scene to move:', sceneBlock);
            
            // Ensure it's actually a scene
            if (sceneBlock.isContainer) {
                console.log('Cannot move container');
                return;
            }
            
            if (sceneBlock.type !== 'scene') {
                console.log('Not a scene, type is:', sceneBlock.type);
                return;
            }

            // Find all blocks that belong to this scene (from this scene until the next scene)
            const blocksToMove = [];
            let currentIndex = fromIndex;
            
            // Add the scene itself
            blocksToMove.push(this.state[currentIndex]);
            currentIndex++;
            
            // Add all blocks until we hit another scene or container
            while (currentIndex < this.state.length) {
                const block = this.state[currentIndex];
                if (block.isContainer) {
                    // Containers break scene groups
                    break;
                }
                if (block.type === 'scene') {
                    // Next scene found, stop
                    break;
                }
                blocksToMove.push(block);
                currentIndex++;
            }
            
            console.log('Moving', blocksToMove.length, 'blocks (scene + content)');
            
            // Remove all blocks from old position (in reverse to maintain indices)
            for (let i = blocksToMove.length - 1; i >= 0; i--) {
                this.state.splice(fromIndex, 1);
            }
            console.log('Removed blocks, new state length:', this.state.length);
            
            // Adjust target index if needed
            if (toIndex > fromIndex) {
                toIndex -= blocksToMove.length;
                console.log('Adjusted toIndex to:', toIndex);
            }

            // Ensure toIndex is valid
            if (toIndex < 0) toIndex = 0;
            if (toIndex > this.state.length) toIndex = this.state.length;

            // Insert all blocks at new position (in reverse to maintain order)
            for (let i = blocksToMove.length - 1; i >= 0; i--) {
                this.state.splice(toIndex, 0, blocksToMove[i]);
            }
            console.log('Inserted blocks at index:', toIndex, 'new state length:', this.state.length);
            
            this.save();
            this.render();
            console.log('Render complete');
            
            // Scroll to the moved scene and highlight it
            setTimeout(() => {
                const movedRow = document.getElementById(`row-${toIndex}`);
                if (movedRow) {
                    movedRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    movedRow.classList.add('jump-highlight');
                    setTimeout(() => {
                        movedRow.classList.remove('jump-highlight');
                    }, 2000);
                    console.log('Scrolled to moved scene at row-', toIndex);
                } else {
                    console.log('Could not find moved scene row-', toIndex);
                }
            }, 100);
        }
    }

    const app = new Engine();
</script>
</body>
</html>
